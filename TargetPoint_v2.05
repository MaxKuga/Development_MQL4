//+------------------------------------------------------------------+
//|                                          TargetPoint_v2.05.mq4   |
//|                        Copyright 2025, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Built by MaximK"
#property link      ""
#property version   "2.05"
#property strict
#property description "TargetPoint Expert Advisor with simplified line logic, DailyExtremeBreak, Pin Bar, and auto BE-by-line"

// ====================== ENUMS =====================================
enum TradeDirectionEnum { NoTrade = 0, OnlyBuy = 1, OnlySell = 2 };
enum HLinePickModeEnum  { NearestToPrice = 0, LastCreated = 1 };
enum BreakevenModeEnum  { BE_Standard = 0, BE_ByDashedHLine = 1 };
enum StopModeEnum       { SL_ATR_D1 = 0, SL_LocalExtreme = 1 };
datetime DayStartServer();
int      CountLosingTradesToday();
bool     CanTradeToday();
void     EnforceDailyLossLimit();

// ====================== INPUTS (упрощённые) =======================
// Направление
input TradeDirectionEnum InputTradeDir       = OnlyBuy; // Initial Trade Direction
// Риск/SL/TP
input double      RiskPercent                = 1.0;     // Risk %
input double      SL_Percent                 = 0.25;    // SL % ATR(D1)
input double      TP_RR                      = 5.0;     // TP Risk Reward
input int         MaxLosingTradesPerDay      = 1;       // Max loss trades/day (0 = no limit)
// Паттерны (единый список)
input bool        UseABLimit                 = true;    // Use AB Limit pattern
input bool        UseABMarket                = true;    // Use AB Market pattern
input bool        UseDailyExtremeBreak       = true;    // Use DailyExtremeBreak pattern
input bool        UsePinBar                  = true;    // Use Pin Bar pattern
// Общее для всех паттернов
input bool        UseExtremeSL               = false;   // Use SL beyond extreme (applies to DEB & PinBar)
// Окна и ATR
input int         SearchWindowBars           = 200;     // Search Window Bars (H1) for patterns (line mode)
input int         MaxGapBarsBetweenSignals   = 10;      // Max Bars Between Signals / also pending expiry
input int         H1_AvgRangePeriod          = 24;      // ATR(H1)
input int         D1_AvgRangePeriod          = 20;      // ATR(D1)
// Фильтр диапазона H1 (общий, применяется в Pin Bar)
input bool        UseAtrH1RangeFilter        = true;    // ATR(H1) range filter for Pin Bar
input double      MinRangeATRH1              = 0.5;     // Min candle range of ATR(H1) for Pin Bar
// Прочие
input double      MinImpulseATR              = 1.0;     // Min Impulse ATR
input double      CloseZonePercent           = 40.0;    // Close candle Zone%
input bool        Debug                      = false;    // Debug Mode
input bool        ShowImpulseDots            = true;    // Show Impulse Arrows
input int         ImpulseScanBars            = 200;     // Impulse Scan Bars
input int         ImpulseDotCode             = 159;     // Impulse Dot Code (Wingdings)
input int         ImpulseOffsetPoints        = 5;       // Impulse Offset Points
input int         MagicNumber                = 20250930;// Magic number
input int         StartHour                  = 6;       // Start hour
input int         StartMinute                = 0;       // Start minute
input int         EndHour                    = 22;      // End hour
input int         EndMinute                  = 0;       // End minute
input bool debug = false; // Отладка: true - принты, false - без
input double LimitOffsetPips = 50; // Смещение лимит-линии в пипсах
// Pin Bar только режим источника SL (без отдельного коэффициента ATR)
input StopModeEnum PinBarStopMode            = SL_LocalExtreme; // Pin Bar SL source
// === Day helpers & daily loss limit =================================
datetime DayStartServer() { return iTime(Symbol(), PERIOD_D1, 0); } // старт дня по времени брокера

int CountLosingTradesToday()
{
   const double EPS = 1e-8;
   datetime dayStart = DayStartServer();
   int losses = 0;

   int total = OrdersHistoryTotal();
   for(int i=0; i<total; i++)
   {
      if(!OrderSelect(i, SELECT_BY_POS, MODE_HISTORY)) continue;
      if(OrderSymbol() != _Symbol)                  continue;
      if(OrderMagicNumber() != MagicNumber)         continue;

      int t = OrderType();
      if(t!=OP_BUY && t!=OP_SELL)                   continue; // только закрытые рыночные
      datetime ct = OrderCloseTime();
      if(ct < dayStart)                              continue; // только текущий день

      double pnl = OrderProfit() + OrderSwap() + OrderCommission();
      if(pnl < -EPS) losses++;
   }
   return losses;
}

bool CanTradeToday()
{
   if(MaxLosingTradesPerDay <= 0) return true;
   return (CountLosingTradesToday() < MaxLosingTradesPerDay);
}

// печать один раз в день при блокировке + снятие pending
void EnforceDailyLossLimit()
{
   static datetime lastDay = 0;
   static bool blocked = false;

   datetime today = DayStartServer();
   if(today != lastDay) { lastDay = today; blocked = false; } // новый день — разблок

   if(MaxLosingTradesPerDay > 0 && CountLosingTradesToday() >= MaxLosingTradesPerDay)
   {
      if(!blocked){
         if(Debug) Print("[DAILY-LOSS-LIMIT] Trading blocked for today. losses=",
                         CountLosingTradesToday()," limit=",MaxLosingTradesPerDay,
                         " dayStart=",TimeToString(today));
         blocked = true;
      }
      CancelAllPendings();
   }
}
// ====================== ЖЁСТКИЕ НАСТРОЙКИ =========================
const HLinePickModeEnum kHLinePickMode     = NearestToPrice;
const HLinePickModeEnum kBE_HLinePickMode  = NearestToPrice;
const bool  kReplacePendingOnNewPattern    = true;
const bool  kOnePositionOnly               = true;
const double kMaxSpreadPoints              = -1;        // (-1 отключено)
const int    kMaxSlippagePoints            = 20;
// "NoLine" рынок/лимит
const int    kNoLine_PatternScanBars       = 5;
const bool   kNoLine_UsePending            = true;
const bool   kNoLine_UseMarket             = true;
// Визуал
const color  kImpulseBullDotColor          = clrLime;
const color  kImpulseBearDotColor          = clrRed;
// BE offset скрыт из меню
const int    kBreakevenOffsetPoints        = 10;        // скрытый дефолт
// ====================== КНОПКИ ДИРЕКШНА ===========================
const string kBuyButtonName      = "TP_BUY_BTN";
const string kSellButtonName     = "TP_SELL_BTN";
const string kOffButtonName      = "TP_OFF_BTN";
const string kBEButtonName       = "TP_BE_BTN";
const string kLimitButtonName    = "TP_LIMIT_BTN";
const string kCloseAllButtonName = "TP_CLOSEALL_BTN";
const color  kButtonTextColor    = clrBlack;
const color  kInactiveBGColor    = clrWhite;
const color  kBuyActiveBGColor   = clrLime;
const color  kSellActiveBGColor  = clrRed;
const color  kOffActiveBGColor   = clrGray;
const color  kBEButtonBGColor    = clrYellow;
const color  kLimitButtonBGColor = clrAqua;
const color  kCloseAllButtonBGColor = clrPink;

// ====================== Глобальные ================================
int CurrentTradeDir = NoTrade;
BreakevenModeEnum CurrentBreakevenMode = BE_Standard;

double   Level = 0.0;
string   SelectedHLineName = "";

string   LimitLineName = "TP_LIMIT_LINE";
double   LimitLevel = 0.0;
bool     LimitActive = false;

struct Pattern {
   int A_shift;
   int B_shift;
   double OpenA;
   datetime A_time;
   datetime B_time;
   string Key;
};
Pattern CurrentPattern = { -1, -1, 0.0, 0, 0, "" };

// --- PIN BAR LOGIC ---
struct SignalInfo {
   bool   valid;
   bool   isBuy;
   string pattern;
   double entryPrice;
   double slPrice;
   double tpPrice;
   double localSL;
};
SignalInfo CurrentSignal = { false, false, "", 0.0, 0.0, 0.0, 0.0 };

struct SignalCandle {
   int shift;
   datetime time;
   double extreme;      // high for SELL, low for BUY
   double entry_level;  // low for SELL, high for BUY
   string Key;
};
SignalCandle CurrentSignalBuy  = { -1, 0, 0.0, 0.0, "" };
SignalCandle CurrentSignalSell = { -1, 0, 0.0, 0.0, "" };
datetime CurrentDay = 0;

int BE_DoneTickets[100];
int BE_DoneCount = 0;

datetime LastH1BarTime = 0;

double g_prevBid = 0.0;
double g_prevAsk = 0.0;
bool   g_prevInited = false;

double   ATR_H1_avg = 0.0;
double   ATR_D1_avg = 0.0;
double   CloseZone  = 0.0;

int      PendingTicket = 0;
datetime PendingPlaceTime = 0;
int      PendingPlaceH1BarIndex = 0;
string   PendingPatternKey = "";

#define MAX_USED_KEYS 512
string   UsedKeys[MAX_USED_KEYS];
int      UsedKeysCount = 0;

// ------------------------------------------------------------------
// Helpers
// ------------------------------------------------------------------
int CountOpenPositions(){
   int c=0;
   for(int i=OrdersTotal()-1;i>=0;i--){
      if(!OrderSelect(i,SELECT_BY_POS,MODE_TRADES)) continue;
      if(OrderSymbol()!=Symbol()) continue;
      if(OrderMagicNumber()!=MagicNumber) continue;
      int t=OrderType();
      if(t==OP_BUY||t==OP_SELL) c++;
   }
   return c;
}
int CountPendings(){
   int c=0;
   for(int i=OrdersTotal()-1;i>=0;i--){
      if(!OrderSelect(i,SELECT_BY_POS,MODE_TRADES)) continue;
      if(OrderSymbol()!=Symbol()) continue;
      if(OrderMagicNumber()!=MagicNumber) continue;
      int t=OrderType();
      if(t==OP_BUYLIMIT||t==OP_SELLLIMIT||t==OP_BUYSTOP||t==OP_SELLSTOP) c++;
   }
   return c;
}
void CancelAllPendings(){
   for(int i=OrdersTotal()-1;i>=0;i--){
      if(!OrderSelect(i,SELECT_BY_POS,MODE_TRADES)) continue;
      if(OrderSymbol()!=Symbol()) continue;
      if(OrderMagicNumber()!=MagicNumber) continue;
      int t=OrderType();
      if(t==OP_BUYLIMIT||t==OP_SELLLIMIT||t==OP_BUYSTOP||t==OP_SELLSTOP){
         int tk=OrderTicket();
         if(!OrderDelete(tk)){
            if (debug) Print("CancelAllPendings: fail delete ",tk," err=",GetLastError());
         }else if(tk==PendingTicket){
            PendingTicket=0;
            PendingPatternKey = "";
         }
      }
   }
}
void CloseAll(){
   for(int i=OrdersTotal()-1;i>=0;i--){
      if(!OrderSelect(i,SELECT_BY_POS,MODE_TRADES)) continue;
      if(OrderSymbol()!=Symbol()) continue;
      if(OrderMagicNumber()!=MagicNumber) continue;
      int t=OrderType();
      if(t==OP_BUY){
         if(!OrderClose(OrderTicket(),OrderLots(),Bid,kMaxSlippagePoints,clrRed)){
            if (debug) Print("CloseAll: fail close BUY ",OrderTicket()," err=",GetLastError());
         }
      }else if(t==OP_SELL){
         if(!OrderClose(OrderTicket(),OrderLots(),Ask,kMaxSlippagePoints,clrRed)){
            if (debug) Print("CloseAll: fail close SELL ",OrderTicket()," err=",GetLastError());
         }
      }
   }
   CancelAllPendings();
   if (debug) Print("CloseAll executed.");
}
bool IsDirectionAllowed(int type){
   if (CurrentTradeDir==OnlyBuy && (type==OP_SELL || type==OP_SELLLIMIT || type==OP_SELLSTOP)) return false;
   if (CurrentTradeDir==OnlySell && (type==OP_BUY || type==OP_BUYLIMIT || type==OP_BUYSTOP )) return false;
   return (CurrentTradeDir!=NoTrade);
}

// Проверка, была ли прибыльная сделка сегодня
bool HasProfitableTradeToday() {
   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);
   datetime today_start = TimeCurrent() - (dt.hour * 3600 + dt.min * 60 + dt.sec);

   for(int i=OrdersHistoryTotal()-1; i>=0; i--) {
      if(!OrderSelect(i, SELECT_BY_POS, MODE_HISTORY)) continue;
      if(OrderSymbol() != Symbol() || OrderMagicNumber() != MagicNumber) continue;
      if(OrderCloseTime() < today_start) continue;
      if(OrderProfit() > 0) return true;
   }
   return false;
}
// --- линии ---
bool HasAnyValidSolidHLine(){
   int total=ObjectsTotal();
   for(int i=0;i<total;i++){
      string name=ObjectName(i);
      if(ObjectType(name)!=OBJ_HLINE) continue;
      if(StringFind(name,"TP_")==0) continue; // служебные
      int style=(int)ObjectGetInteger(0,name,OBJPROP_STYLE);
      if(style!=STYLE_SOLID) continue;
      return true;
   }
   return false;
}
bool NoLineModeActive(){
   // Авто-режим: нет торговой SOLID линии => NoLine
   return !HasAnyValidSolidHLine();
}
bool HasDashedLine(){
   int total=ObjectsTotal();
   for(int i=0;i<total;i++){
      string name=ObjectName(i);
      if(ObjectType(name)!=OBJ_HLINE) continue;
      // НЕ исключаем TP_BE_LINE — именно её и нужно увидеть
      int style=(int)ObjectGetInteger(0,name,OBJPROP_STYLE);
      if(style==STYLE_DASH || style==STYLE_DASHDOT || style==STYLE_DASHDOTDOT) return true;
   }
   return false;
}
void UpdateBreakevenMode(){
   bool hasDashed = HasDashedLine();
   if(hasDashed && CurrentBreakevenMode != BE_ByDashedHLine){
      CurrentBreakevenMode = BE_ByDashedHLine;
      if (debug) Print("Dashed line detected. Breakeven mode switched to BE_ByDashedHLine.");
   }else if(!hasDashed && CurrentBreakevenMode != BE_Standard){
      CurrentBreakevenMode = BE_Standard;
      if (debug) Print("No dashed line. Breakeven mode switched back to BE_Standard.");
   }
}

// Проверка сессии
bool IsInSession(datetime t){
   int h = TimeHour(t);
   int m = TimeMinute(t);
   int start = StartHour*60 + StartMinute;
   int end   = EndHour*60 + EndMinute;
   int cur   = h*60 + m;
   return (cur >= start && cur < end);
}

// Проверка текущего дня
bool IsToday(datetime t){
   MqlDateTime dt;
   TimeToStruct(t, dt);
   MqlDateTime current_dt;
   TimeToStruct(TimeCurrent(), current_dt);
   return (dt.day == current_dt.day && dt.mon == current_dt.mon && dt.year == current_dt.year);
}

// === Breakeven by dashed HLine ===
bool GetDashedBreakevenLine(double &priceOut,string &lineNameOut){
   priceOut=0.0; lineNameOut="";
   int total=ObjectsTotal(); if(total<=0) return false;

   double mid=(Ask+Bid)/2.0;
   double bestDist=DBL_MAX;
   string bestName=""; double bestPrice=0.0;

   if(kBE_HLinePickMode==NearestToPrice){
      for(int i=0;i<total;i++){
         string name=ObjectName(i);
         if(ObjectType(name)!=OBJ_HLINE) continue;
         int style=(int)ObjectGetInteger(0,name,OBJPROP_STYLE);
         if(style==STYLE_SOLID) continue;
         double price=ObjectGetDouble(0,name,OBJPROP_PRICE,0);
         if(price==0.0) continue;
         double d=MathAbs(price-mid);
         if(d<bestDist){ bestDist=d; bestName=name; bestPrice=price; }
      }
   }else{
      for(int i=total-1;i>=0;i--){
         string name=ObjectName(i);
         if(ObjectType(name)!=OBJ_HLINE) continue;
         int style=(int)ObjectGetInteger(0,name,OBJPROP_STYLE);
         if(style==STYLE_SOLID) continue;
         double price=ObjectGetDouble(0,name,OBJPROP_PRICE,0);
         if(price==0.0) continue;
         bestName=name; bestPrice=price; break;
      }
   }
   if(bestName=="") return false;
   priceOut=NormalizeDouble(bestPrice,Digits);
   lineNameOut=bestName;
   return true;
}
void ManageBreakevenByLine(){
   double beLine=0.0; string lineName="";
   if(!GetDashedBreakevenLine(beLine,lineName)) return;

   for(int i=OrdersTotal()-1;i>=0;i--){
      if(!OrderSelect(i,SELECT_BY_POS,MODE_TRADES)) continue;
      if(OrderSymbol()!=Symbol() || OrderMagicNumber()!=MagicNumber) continue;
      int type=OrderType();
      if(type!=OP_BUY && type!=OP_SELL) continue;

      int ticket=OrderTicket();
      double entry=OrderOpenPrice();
      double tp=OrderTakeProfit();
      double offset=kBreakevenOffsetPoints*Point;

      if(IsBEDone(ticket)) continue;
      if(WasJustActivated(ticket)) continue;

      bool trigger=false;
      double desiredSL=OrderStopLoss();

      if(type==OP_BUY){
         if(beLine<=entry) continue;
         if(CrossedUp(beLine)){
            desiredSL=NormalizeDouble(entry+offset,Digits);
            desiredSL=MathMin(desiredSL,Bid-2*Point);
            if(desiredSL>OrderStopLoss()) trigger=true;
         }
      }else{
         if(beLine>=entry) continue;
         if(CrossedDown(beLine)){
            desiredSL=NormalizeDouble(entry-offset,Digits);
            desiredSL=MathMax(desiredSL,Ask+2*Point);
            if(desiredSL<OrderStopLoss()) trigger=true;
         }
      }
      if(trigger){
         if(OrderModify(ticket,entry,desiredSL,tp,0,clrGreen)){
            if(Debug) PrintFormat("[BE-Line] %s crossed %.5f -> BE set (ticket %d, SL=%.5f)",lineName,beLine,ticket,desiredSL);
            AddBEDone(ticket);
         }else{
            Print("[BE-Line] Error setting breakeven: ",GetLastError()," ticket=",ticket);
         }
      }
   }
}

// === Фильтр геометрии относительно SOLID-линии ===
bool IsValidByLineGeometry(bool isBuy, double refPrice)
{
   if (!HasAnyValidSolidHLine()) return true; // в NoLine режим-фильтр не применяется
   double limit = (MaxGapBarsBetweenSignals>0 ? DBL_MAX : DBL_MAX); // лимит по ATR ниже
   if (SL_Percent>0 && ATR_D1_avg>0){
      double maxATR = (MaxEntryDistanceATR()) * ATR_D1_avg; // см. функцию ниже
      if (maxATR>0) limit = maxATR;
   }
   double dist  = MathAbs(refPrice - Level);
   if (isBuy){
      if (refPrice > Level) return false;
      return (dist <= limit);
   }else{
      if (refPrice < Level) return false;
      return (dist <= limit);
   }
}
double MaxEntryDistanceATR(){
   // Совместимость со старой логикой: допускаем половину дневного ATR как максимум,
   return 0.5; // 0.5 * ATR(D1)
}

// === Управление Limit Line ===
void UpdateLimitLine(){
   if(ObjectFind(0,LimitLineName) < 0){
      LimitActive = false;
      LimitLevel = 0.0;
      return;
   }
   LimitLevel = NormalizeDouble(ObjectGetDouble(0,LimitLineName,OBJPROP_PRICE,0), Digits);
   LimitActive = true;
}
//+------------------------------------------------------------------+
//| Create limit line                                                |
//+------------------------------------------------------------------+
void CreateLimitLine()
{
   double pip = PipSize();
   double offset = LimitOffsetPips * pip;
   double price = 0;
   if (CurrentTradeDir == OnlyBuy) price = Ask + offset;
   if (CurrentTradeDir == OnlySell) price = Bid - offset;
   if (price <= 0) return;
   
   price = NormalizeDouble(price, Digits);
   
   if (ObjectFind(0, LimitLineName) >= 0) ObjectDelete(0, LimitLineName);
   
   ObjectCreate(0, LimitLineName, OBJ_HLINE, 0, 0, price);
   ObjectSetInteger(0, LimitLineName, OBJPROP_STYLE, STYLE_DOT);
   ObjectSetInteger(0, LimitLineName, OBJPROP_COLOR, clrYellow);
   ObjectSetInteger(0, LimitLineName, OBJPROP_WIDTH, 1);
   
   if (debug) Print("Limit line created at ", DoubleToStr(price, Digits));
   ChartRedraw();
}
void CheckLimitTouch(){
   if(!LimitActive || CurrentTradeDir == NoTrade) return;
   if(kOnePositionOnly && CountOpenPositions() > 0) return;

   bool triggered = false;
   if(CurrentTradeDir == OnlyBuy){
      if(CrossedUp(LimitLevel)){
         triggered = true;
      }
   }else if(CurrentTradeDir == OnlySell){
      if(CrossedDown(LimitLevel)){
         triggered = true;
      }
   }
   if(triggered){
      double entry = (CurrentTradeDir == OnlyBuy) ? Ask : Bid;
      double sl_dist = SL_Percent * ATR_D1_avg;
      double sl, tp;
      if(CurrentTradeDir == OnlyBuy){
         sl = NormalizeDouble(entry - sl_dist, Digits);
         tp = NormalizeDouble(entry + TP_RR * sl_dist, Digits);
      }else{
         sl = NormalizeDouble(entry + sl_dist, Digits);
         tp = NormalizeDouble(entry - TP_RR * sl_dist, Digits);
      }
     double lot = CalculateLot(entry, sl);
if(lot > 0)
{
   // ⛔️ DAILY LOSS LIMIT — проверка перед отправкой ордера
   if(!CanTradeToday())
   {
      Print("[DAILY-LOSS-LIMIT] Blocked: losses=", CountLosingTradesToday(),
            " limit=", MaxLosingTradesPerDay);
      return; // выходим, ордер не отправляем
   }

   int type = (CurrentTradeDir == OnlyBuy) ? OP_BUY : OP_SELL;
   string cmt = "LimitTouch";
   int ticket = OrderSend(Symbol(), type, lot, entry, kMaxSlippagePoints, sl, tp, cmt, MagicNumber, 0, clrBlue);
   if(ticket > 0){
      Print("Limit line touched. Market order opened: ", ticket);
      ObjectDelete(0, LimitLineName);
      LimitActive = false;
      LimitLevel = 0.0;
   }else{
      Print("Error opening Limit order: ", GetLastError());
   }
}

         }
      }


// === Кнопки направления ===
void CreateDirectionButtons(){
   int btn_width=60, btn_height=25, y_pos=30, x_start=10;

   if (ObjectFind(0,kBuyButtonName)<0) ObjectCreate(0,kBuyButtonName,OBJ_BUTTON,0,0,0);
   ObjectSetInteger(0,kBuyButtonName,OBJPROP_XDISTANCE,x_start);
   ObjectSetInteger(0,kBuyButtonName,OBJPROP_YDISTANCE,y_pos);
   ObjectSetInteger(0,kBuyButtonName,OBJPROP_XSIZE,btn_width);
   ObjectSetInteger(0,kBuyButtonName,OBJPROP_YSIZE,btn_height);
   ObjectSetString (0,kBuyButtonName,OBJPROP_TEXT,"BUY");
   ObjectSetInteger(0,kBuyButtonName,OBJPROP_COLOR,kButtonTextColor);
   ObjectSetInteger(0,kBuyButtonName,OBJPROP_BGCOLOR,(CurrentTradeDir==OnlyBuy? kBuyActiveBGColor:kInactiveBGColor));
   ObjectSetInteger(0,kBuyButtonName,OBJPROP_BORDER_COLOR,clrBlack);
   ObjectSetInteger(0,kBuyButtonName,OBJPROP_STATE,false);

   if (ObjectFind(0,kSellButtonName)<0) ObjectCreate(0,kSellButtonName,OBJ_BUTTON,0,0,0);
   ObjectSetInteger(0,kSellButtonName,OBJPROP_XDISTANCE,x_start+btn_width+5);
   ObjectSetInteger(0,kSellButtonName,OBJPROP_YDISTANCE,y_pos);
   ObjectSetInteger(0,kSellButtonName,OBJPROP_XSIZE,btn_width);
   ObjectSetInteger(0,kSellButtonName,OBJPROP_YSIZE,btn_height);
   ObjectSetString (0,kSellButtonName,OBJPROP_TEXT,"SELL");
   ObjectSetInteger(0,kSellButtonName,OBJPROP_COLOR,kButtonTextColor);
   ObjectSetInteger(0,kSellButtonName,OBJPROP_BGCOLOR,(CurrentTradeDir==OnlySell? kSellActiveBGColor:kInactiveBGColor));
   ObjectSetInteger(0,kSellButtonName,OBJPROP_BORDER_COLOR,clrBlack);
   ObjectSetInteger(0,kSellButtonName,OBJPROP_STATE,false);

   if (ObjectFind(0,kOffButtonName)<0) ObjectCreate(0,kOffButtonName,OBJ_BUTTON,0,0,0);
   ObjectSetInteger(0,kOffButtonName,OBJPROP_XDISTANCE,x_start+2*(btn_width+5));
   ObjectSetInteger(0,kOffButtonName,OBJPROP_YDISTANCE,y_pos);
   ObjectSetInteger(0,kOffButtonName,OBJPROP_XSIZE,btn_width);
   ObjectSetInteger(0,kOffButtonName,OBJPROP_YSIZE,btn_height);
   ObjectSetString (0,kOffButtonName,OBJPROP_TEXT,"OFF");
   ObjectSetInteger(0,kOffButtonName,OBJPROP_COLOR,kButtonTextColor);
   ObjectSetInteger(0,kOffButtonName,OBJPROP_BGCOLOR,(CurrentTradeDir==NoTrade? kOffActiveBGColor:kInactiveBGColor));
   ObjectSetInteger(0,kOffButtonName,OBJPROP_BORDER_COLOR,clrBlack);
   ObjectSetInteger(0,kOffButtonName,OBJPROP_STATE,false);

   if (ObjectFind(0,kBEButtonName)<0) ObjectCreate(0,kBEButtonName,OBJ_BUTTON,0,0,0);
   ObjectSetInteger(0,kBEButtonName,OBJPROP_XDISTANCE,x_start+3*(btn_width+5));
   ObjectSetInteger(0,kBEButtonName,OBJPROP_YDISTANCE,y_pos);
   ObjectSetInteger(0,kBEButtonName,OBJPROP_XSIZE,btn_width);
   ObjectSetInteger(0,kBEButtonName,OBJPROP_YSIZE,btn_height);
   ObjectSetString (0,kBEButtonName,OBJPROP_TEXT,"BE");
   ObjectSetInteger(0,kBEButtonName,OBJPROP_COLOR,kButtonTextColor);
   ObjectSetInteger(0,kBEButtonName,OBJPROP_BGCOLOR,kBEButtonBGColor);
   ObjectSetInteger(0,kBEButtonName,OBJPROP_BORDER_COLOR,clrBlack);
   ObjectSetInteger(0,kBEButtonName,OBJPROP_STATE,false);

   if (ObjectFind(0,kLimitButtonName)<0) ObjectCreate(0,kLimitButtonName,OBJ_BUTTON,0,0,0);
   ObjectSetInteger(0,kLimitButtonName,OBJPROP_XDISTANCE,x_start+4*(btn_width+5));
   ObjectSetInteger(0,kLimitButtonName,OBJPROP_YDISTANCE,y_pos);
   ObjectSetInteger(0,kLimitButtonName,OBJPROP_XSIZE,btn_width);
   ObjectSetInteger(0,kLimitButtonName,OBJPROP_YSIZE,btn_height);
   ObjectSetString (0,kLimitButtonName,OBJPROP_TEXT,"Limit");
   ObjectSetInteger(0,kLimitButtonName,OBJPROP_COLOR,kButtonTextColor);
   ObjectSetInteger(0,kLimitButtonName,OBJPROP_BGCOLOR,kLimitButtonBGColor);
   ObjectSetInteger(0,kLimitButtonName,OBJPROP_BORDER_COLOR,clrBlack);
   ObjectSetInteger(0,kLimitButtonName,OBJPROP_STATE,false);

   if (ObjectFind(0,kCloseAllButtonName)<0) ObjectCreate(0,kCloseAllButtonName,OBJ_BUTTON,0,0,0);
   ObjectSetInteger(0,kCloseAllButtonName,OBJPROP_XDISTANCE,x_start+5*(btn_width+5));
   ObjectSetInteger(0,kCloseAllButtonName,OBJPROP_YDISTANCE,y_pos);
   ObjectSetInteger(0,kCloseAllButtonName,OBJPROP_XSIZE,btn_width);
   ObjectSetInteger(0,kCloseAllButtonName,OBJPROP_YSIZE,btn_height);
   ObjectSetString (0,kCloseAllButtonName,OBJPROP_TEXT,"CloseAll");
   ObjectSetInteger(0,kCloseAllButtonName,OBJPROP_COLOR,kButtonTextColor);
   ObjectSetInteger(0,kCloseAllButtonName,OBJPROP_BGCOLOR,kCloseAllButtonBGColor);
   ObjectSetInteger(0,kCloseAllButtonName,OBJPROP_BORDER_COLOR,clrBlack);
   ObjectSetInteger(0,kCloseAllButtonName,OBJPROP_STATE,false);

   ChartRedraw();
}
void UpdateButtonColors(){
   ObjectSetInteger(0,kBuyButtonName, OBJPROP_BGCOLOR,(CurrentTradeDir==OnlyBuy ? kBuyActiveBGColor : kInactiveBGColor));
   ObjectSetInteger(0,kSellButtonName,OBJPROP_BGCOLOR,(CurrentTradeDir==OnlySell? kSellActiveBGColor: kInactiveBGColor));
   ObjectSetInteger(0,kOffButtonName, OBJPROP_BGCOLOR,(CurrentTradeDir==NoTrade ? kOffActiveBGColor  : kInactiveBGColor));
   ChartRedraw();
   if (Debug) Print("Trade Direction changed to: ", (CurrentTradeDir==OnlyBuy?"OnlyBuy":(CurrentTradeDir==OnlySell?"OnlySell":"NoTrade")));
}
void CheckButtonStates(){
   if (ObjectGetInteger(0,kBuyButtonName,OBJPROP_STATE)){
      CurrentTradeDir=OnlyBuy;
      ObjectSetInteger(0,kBuyButtonName,OBJPROP_STATE,false);
      UpdateButtonColors();
      if (Debug) Print("[Button] BUY clicked (tester workaround)");
   }
   if (ObjectGetInteger(0,kSellButtonName,OBJPROP_STATE)){
      CurrentTradeDir=OnlySell;
      ObjectSetInteger(0,kSellButtonName,OBJPROP_STATE,false);
      UpdateButtonColors();
      if (Debug) Print("[Button] SELL clicked (tester workaround)");
   }
   if (ObjectGetInteger(0,kOffButtonName,OBJPROP_STATE)){
      CurrentTradeDir=NoTrade;
      ObjectSetInteger(0,kOffButtonName,OBJPROP_STATE,false);
      UpdateButtonColors();
      if (Debug) Print("[Button] OFF clicked (tester workaround)");
   }

   if (ObjectGetInteger(0,kBEButtonName,OBJPROP_STATE)){
      ObjectSetInteger(0,kBEButtonName,OBJPROP_STATE,false);
      double pip = PipSize();
      double offset = 30.0 * pip;
      double price = NormalizeDouble((Ask + Bid)/2 + offset, Digits);
      string beLineName = "TP_BE_LINE";
      if(ObjectFind(0,beLineName) >= 0) ObjectDelete(0, beLineName);
      ObjectCreate(0,beLineName, OBJ_HLINE, 0, 0, price);
      ObjectSetInteger(0,beLineName, OBJPROP_STYLE, STYLE_DASH);
      ObjectSetInteger(0,beLineName, OBJPROP_COLOR, clrGreen);
      ObjectSetInteger(0,beLineName, OBJPROP_WIDTH, 1);
      ChartRedraw();
      Print("BE line created at ", DoubleToStr(price, Digits));
   }
   if (ObjectGetInteger(0,kLimitButtonName,OBJPROP_STATE)){
      ObjectSetInteger(0,kLimitButtonName,OBJPROP_STATE,false);
      CreateLimitLine();
   }

   if (ObjectGetInteger(0,kCloseAllButtonName,OBJPROP_STATE)){
      ObjectSetInteger(0,kCloseAllButtonName,OBJPROP_STATE,false);
      CloseAll();
   }
}

// ===================== АНТИ-ПОВТОР ПАТТЕРНА ======================
string ComposePatternKey(bool lineMode,bool isBuy,datetime a_time,datetime b_time){
   string mode=lineMode?"LINE":"NL";
   string dir =isBuy?"BUY":"SELL";
   string lkey=lineMode?SelectedHLineName:"NL";
   return StringFormat("%s|%s|%d|%d|%s",mode,dir,a_time,b_time,lkey);
}
bool IsKeyUsed(string key){ if(key=="")return false; for(int i=0;i<UsedKeysCount;i++) if(UsedKeys[i]==key) return true; return false; }
void AddUsedKey(string key){
   if(key==""||IsKeyUsed(key))return;
   if(UsedKeysCount<MAX_USED_KEYS){ UsedKeys[UsedKeysCount++]=key; if(Debug) Print("[AntiRepeat] Mark used: ",key); }
   else if(Debug) Print("[AntiRepeat] Buffer full, cannot add: ",key);
}
bool TryParseKeyFromComment(string cmt,string &keyOut){
   int pos=StringFind(cmt,"PK:");
   if(pos<0) return false;
   keyOut=StringSubstr(cmt,pos+3);
   StringTrimLeft(keyOut); StringTrimRight(keyOut);
   return (keyOut!="");
}

// --- PIN BAR LOGIC ---
// Вспомогательные функции для свечей (H1 timeframe)
double CandleOpen(int shift)  { return iOpen(Symbol(), PERIOD_H1, shift); }
double CandleClose(int shift) { return iClose(Symbol(), PERIOD_H1, shift); }
double CandleHigh(int shift)  { return iHigh(Symbol(),  PERIOD_H1, shift); }
double CandleLow(int shift)   { return iLow(Symbol(),   PERIOD_H1, shift); }
double CandleRange(int shift) { return CandleHigh(shift) - CandleLow(shift); }

// Нормализация и вспомогательные
double Norm(double p) { return NormalizeDouble(p, Digits); }
double Pt() { return Point; }

// Фильтр ATR H1 для диапазона свечи
bool PassAtrH1RangeFilter(int shift){
   if(!UseAtrH1RangeFilter) return true;
   if(ATR_H1_avg <= 0) return false;
   double rng = CandleRange(shift);
   return (rng >= MinRangeATRH1 * ATR_H1_avg);
}

// Фильтр экстремума дня для Pin Bar
bool AlmostEqual(double a, double b){ double eps = MathMax(Point*0.5, 1e-10); return (MathAbs(a-b) <= eps); }
bool PassDayExtremeFilter(bool isBuy){
   double dayHigh = iHigh(Symbol(), PERIOD_D1, 0);
   double dayLow  = iLow (Symbol(), PERIOD_D1, 0);
   if(isBuy) return AlmostEqual(CandleLow(1), dayLow);
   else      return AlmostEqual(CandleHigh(1), dayHigh);
}

// Детекция Pin Bar на закрытой свече (shift=1)
bool Detect_PinBar(int shift, bool &isBuy){
   double O = CandleOpen(shift);
   double C = CandleClose(shift);
   double H = CandleHigh(shift);
   double L = CandleLow(shift);

   double body = MathAbs(C - O);
   double upper = H - MathMax(O, C);
   double lower = MathMin(O, C) - L;

   double longW = upper; double shortW = lower; bool longIsUpper = true;
   if(lower > upper){ longW = lower; shortW = upper; longIsUpper = false; }

   bool cond1 = (longW >= 2.0 * body);
   bool cond2 = (longW >= 2.0 * shortW);

   if(!(cond1 && cond2)) return false;
   if(!PassAtrH1RangeFilter(shift)) return false;

   isBuy = (!longIsUpper);
   return true;
}

// -------------------------------------------------------------------
// Построение сигнала Pin Bar с проверкой дневного экстремума + окна
// -------------------------------------------------------------------
// ===== Helpers: окно + экстремумы дня (00:00..23:59 брокера) =====
bool IsWithinTradeWindow(datetime t, int startHour, int startMin, int endHour, int endMin)
{
   MqlDateTime md; TimeToStruct(t, md);
   int cur = md.hour*60 + md.min;
   int beg = startHour*60 + startMin;
   int end = endHour*60 + endMin;

   if(beg==end) return true; // 24/7

   if(beg < end) return (cur >= beg && cur < end);      // дневное окно
   return (cur >= beg || cur < end);                    // ночное окно (наперекат)
}

void GetDayHighLow(datetime bar_time, double &dayHigh, double &dayLow)
{
   MqlDateTime md; TimeToStruct(bar_time, md);
   md.hour=0; md.min=0; md.sec=0;
   datetime dayStart = StructToTime(md);
   datetime dayEnd   = dayStart + 24*60*60;

   dayHigh = -DBL_MAX; dayLow = DBL_MAX;

   for(int s=0;; s++)
   {
      datetime t = iTime(NULL, PERIOD_H1, s);
      if(t==0) break;
      if(t < dayStart) break;
      if(t >= dayEnd) continue;

      double h = iHigh(NULL, PERIOD_H1, s);
      double l = iLow (NULL, PERIOD_H1, s);
      if(h > dayHigh) dayHigh = h;
      if(l < dayLow ) dayLow  = l;
   }
}

// ===== Гейт: окно + верный экстремум (BUY=Low дня, SELL=High дня) =====
bool PinBar_DailyExtremeAndWindowGate(int shift, bool isBuy)
{
   datetime bar_time = iTime(NULL, PERIOD_H1, shift);
   if(bar_time==0) return false;

   if(!IsWithinTradeWindow(bar_time, StartHour, StartMinute, EndHour, EndMinute))
      return false;

   double dayHigh, dayLow; GetDayHighLow(bar_time, dayHigh, dayLow);
   double thisHigh = iHigh(NULL, PERIOD_H1, shift);
   double thisLow  = iLow (NULL, PERIOD_H1, shift);

   double eps = (Point>0 ? Point*0.5 : 1e-10);

   if(isBuy)  return (MathAbs(thisLow  - dayLow ) <= eps); // BUY: Low дня
   else       return (MathAbs(thisHigh - dayHigh) <= eps); // SELL: High дня
}
bool BuildSignal_PinBar(SignalInfo &sig){
   if(!UsePinBar) return false;

   bool isBuy = false;
   if(!Detect_PinBar(1, isBuy)) return false;

   if(CurrentTradeDir==OnlyBuy && !isBuy) return false;
   if(CurrentTradeDir==OnlySell &&  isBuy) return false;

   // ✅ Проверка дневного экстремума по всему дню + торговое окно
   if(!PinBar_DailyExtremeAndWindowGate(1, isBuy))
      return false;

   if(!PassDayExtremeFilter(isBuy)) return false;

   // Фильтр по линии, если линия есть
   if(HasAnyValidSolidHLine() && Level != 0.0){
      double refPrice = isBuy ? CandleLow(1) : CandleHigh(1);
      if(!IsValidByLineGeometry(isBuy, refPrice)){
         if(Debug) Print("[PIN] Rejected by line geometry");
         return false;
      }
   }

   sig.valid = true;
   sig.pattern = "PIN";
   sig.isBuy = isBuy;
   sig.entryPrice = isBuy ? Ask : Bid;
   sig.localSL = isBuy ? CandleLow(1) : CandleHigh(1);

   FillSL_TP_PinBar(sig);
   return true;
}
// Расчет SL/TP для Pin Bar (UseExtremeSL общий)
void FillSL_TP_PinBar(SignalInfo &sig){
   double sl = 0.0;

   if (UseExtremeSL){
      // SL за экстремумом пин-бара с ограничением 0.3 ATR(D1)
      double beyond = sig.isBuy ? sig.localSL - Point : sig.localSL + Point;
      double maxDist = 0.3 * ATR_D1_avg;
      double rawDist = MathAbs(sig.entryPrice - beyond);
      if (rawDist > maxDist){
         sl = sig.isBuy ? sig.entryPrice - maxDist : sig.entryPrice + maxDist;
         if(Debug) Print(StringFormat("[PIN] Extreme SL clamped to 0.3 ATR(D1): was %.5f, now %.5f", beyond, sl));
      }else{
         sl = beyond;
      }
   }else{
      if(PinBarStopMode == SL_ATR_D1){
         double dist = SL_Percent * ATR_D1_avg; // общий коэффициент
         sl = sig.isBuy ? sig.entryPrice - dist : sig.entryPrice + dist;
      }else{ // SL_LocalExtreme
         sl = sig.localSL;
         double maxDist = 0.3 * ATR_D1_avg;
         double rawDist = MathAbs(sig.entryPrice - sl);
         if(rawDist > maxDist){
            sl = sig.isBuy ? sig.entryPrice - maxDist : sig.entryPrice + maxDist;
            if(Debug) Print(StringFormat("[PIN] Local SL clamped to 0.3 ATR(D1): adj=%.5f", sl));
         }
      }
   }

   double minDist = 10 * Pt();
   if(sig.isBuy){
      if((sig.entryPrice - sl) < minDist) sl = sig.entryPrice - minDist;
   }else{
      if((sl - sig.entryPrice) < minDist) sl = sig.entryPrice + minDist;
   }
   sig.slPrice = Norm(sl);

   if(TP_RR >= 1.0){
      double distSL = MathAbs(sig.entryPrice - sig.slPrice);
      double tp = sig.isBuy ? (sig.entryPrice + TP_RR * distSL) : (sig.entryPrice - TP_RR * distSL);
      sig.tpPrice = Norm(tp);
   }else{
      sig.tpPrice = 0.0;
   }
}

// Исполнение рыночного ордера для Pin Bar
bool ExecuteSignal_PinBar(const SignalInfo &sig){
   if(!sig.valid) return false;

   if(kReplacePendingOnNewPattern) CancelAllPendings();

   int type = sig.isBuy ? OP_BUY : OP_SELL;
   double entry = sig.entryPrice;
   double lot = CalculateLot(entry, sig.slPrice);
   if(lot <= 0) return false;

   // ⛔️ DAILY LOSS LIMIT — проверка перед входом
   if(!CanTradeToday())
   {
      Print("[DAILY-LOSS-LIMIT] Blocked: losses=", CountLosingTradesToday(),
            " limit=", MaxLosingTradesPerDay);
      return false;
   }

   datetime barTime = iTime(Symbol(), PERIOD_H1, 1);
   bool lineMode = !NoLineModeActive();
   string key = ComposePatternKey(lineMode, sig.isBuy, barTime, 0);
   string cmt = StringFormat("PinBar|PK:%s", key);

   int ticket = OrderSend(Symbol(), type, lot, entry, kMaxSlippagePoints,
                          sig.slPrice, sig.tpPrice, cmt, MagicNumber, 0,
                          sig.isBuy ? clrGreen : clrRed);
   if(ticket > 0){
      AddUsedKey(key);
      if(kOnePositionOnly) CancelAllPendings();
      if(Debug) PrintFormat("[PIN] Market %s executed ticket=%d entry=%.5f SL=%.5f TP=%.5f Key=%s",
                             sig.isBuy ? "Buy" : "Sell", ticket, entry, sig.slPrice, sig.tpPrice, key);
      return true;
   }else{
      Print("[PIN] OrderSend failed: ", GetLastError());
      return false;
   }
}


//+------------------------------------------------------------------+
//| Expert initialization                                    |
//+------------------------------------------------------------------+
int OnInit(){
   CurrentTradeDir = InputTradeDir;
   CurrentBreakevenMode = BE_Standard; // авто-переключение через UpdateBreakevenMode()
   int h1_period = MathMax(H1_AvgRangePeriod,1);
   int d1_period = MathMax(D1_AvgRangePeriod,1);
   if (h1_period!=H1_AvgRangePeriod || d1_period!=D1_AvgRangePeriod)
      if (debug) Print("Warning: AvgRangePeriod forced to minimum 1.");
   CloseZone = CloseZonePercent/100.0;
   UpdateLineLevel();
   UpdateBreakevenMode();
   UpdateLimitLine();
   if(ShowImpulseDots) DrawAllImpulseDots();
   CreateDirectionButtons();
   UsedKeysCount = 0;
   // Инициализация для DailyExtremeBreak
   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);
   CurrentDay = TimeCurrent() - (dt.hour * 3600 + dt.min * 60 + dt.sec); // Начало текущего дня
   return(INIT_SUCCEEDED);
}
void OnDeinit(const int reason){
   ObjectDelete(0,kBuyButtonName);
   ObjectDelete(0,kSellButtonName);
   ObjectDelete(0,kOffButtonName);
   ObjectDelete(0,kBEButtonName);
   ObjectDelete(0,kLimitButtonName);
   ObjectDelete(0,kCloseAllButtonName);
   ObjectDelete(0,LimitLineName);
   ObjectDelete(0,"TP_BE_LINE");
   string prefix="ImpulseDot_";
   for(int i=ObjectsTotal()-1;i>=0;i--){
      string name=ObjectName(i);
      if (StringFind(name,prefix)==0) ObjectDelete(name);
   }
}
void OnChartEvent(const int id,const long &lparam,const double &dparam,const string &sparam){
   if (id==CHARTEVENT_OBJECT_CLICK){
      if (sparam==kBuyButtonName){ CurrentTradeDir=OnlyBuy; UpdateButtonColors(); ObjectSetInteger(0,kBuyButtonName,OBJPROP_STATE,false); }
      if (sparam==kSellButtonName){ CurrentTradeDir=OnlySell; UpdateButtonColors(); ObjectSetInteger(0,kSellButtonName,OBJPROP_STATE,false); }
      if (sparam==kOffButtonName){ CurrentTradeDir=NoTrade; UpdateButtonColors(); ObjectSetInteger(0,kOffButtonName,OBJPROP_STATE,false); }
      if (sparam==kBEButtonName){
         double pip = PipSize();
         double offset = 30.0 * pip;
         double price = NormalizeDouble((Ask + Bid)/2 + offset, Digits);
         string beLineName = "TP_BE_LINE";
         if(ObjectFind(0,beLineName) >= 0) ObjectDelete(0, beLineName);
         ObjectCreate(0,beLineName, OBJ_HLINE, 0, 0, price);
         ObjectSetInteger(0,beLineName, OBJPROP_STYLE, STYLE_DASH);
         ObjectSetInteger(0,beLineName, OBJPROP_COLOR, clrGreen);
         ObjectSetInteger(0,beLineName, OBJPROP_WIDTH, 1);
         ChartRedraw();
         if (debug) Print("BE line created at ", DoubleToStr(price, Digits));
         ObjectSetInteger(0,kBEButtonName,OBJPROP_STATE,false);
      }
      if (sparam==kLimitButtonName){
         CreateLimitLine();
         ObjectSetInteger(0,kLimitButtonName,OBJPROP_STATE,false);
      }
      if (sparam==kCloseAllButtonName){
         CloseAll();
         ObjectSetInteger(0,kCloseAllButtonName,OBJPROP_STATE,false);
      }
   }
}
//+------------------------------------------------------------------+
//| Expert tick                                                      |
//+------------------------------------------------------------------+
void OnTick(){
static datetime last_print = 0;
   if (IsTesting() && TimeCurrent() - last_print < 60) return;
   if (!IsTesting()) last_print = TimeCurrent();

   if (debug) Print("OnTick: Tick at ", TimeToString(TimeCurrent()));
   CheckButtonStates();
EnforceDailyLossLimit();
   if (CurrentTradeDir == NoTrade) return;

   double spread=(Ask-Bid)/Point;
   if (kMaxSpreadPoints>0 && spread>kMaxSpreadPoints){ if (Debug) Print("Spread too high: ",spread," > ",kMaxSpreadPoints); return; }

   CalculateATRs();

   datetime current_h1_time=iTime(NULL,PERIOD_H1,0);
   bool new_h1_bar = (current_h1_time!=LastH1BarTime);
   if (new_h1_bar) LastH1BarTime=current_h1_time;

   UpdateBreakevenMode();
   UpdateLimitLine();
   CheckLimitTouch();

   // Новый день — ресет
   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);
   datetime today_start = TimeCurrent() - (dt.hour * 3600 + dt.min * 60 + dt.sec);
   if (today_start != CurrentDay) {
      CurrentDay = today_start;
      CurrentSignalBuy.shift = -1;
      CurrentSignalSell.shift = -1;
      if (Debug) Print("[DailyExtremeBreak] New day started. Reset signal candles.");
      CancelAllPendings();
   }

   // Проверка на прибыльные сделки
   if (HasProfitableTradeToday()) {
      if (Debug) Print("Profitable trade today. No further trading.");
      return;
   }

   // Лимит убыточных сделок
   if (MaxGapBarsBetweenSignals > 0 && CountLosingTradesToday() >= MaxGapBarsBetweenSignals) {
      // Внимание: оставлено как есть из исходной логики суточного контроля (если хотим — можно вынести отдельный input)
   }
// ⛔️ DAILY LOSS LIMIT — глобальный стоп торговли на день
if(!CanTradeToday())
{
   if(Debug) Print("[DAILY-LOSS-LIMIT] Trading blocked for today. losses=",
                   CountLosingTradesToday(), " limit=", MaxLosingTradesPerDay);
   CancelAllPendings();   // снимаем висящие ордера
   return;                // выходим из OnTick — дальше логика не выполняется
}
   bool noLine = NoLineModeActive();

   // --- PIN BAR LOGIC: приоритет ---
   SignalInfo sig = {false, false, "", 0.0, 0.0, 0.0, 0.0};
   bool pinExecuted = false;
   if (new_h1_bar && kOnePositionOnly && CountOpenPositions() == 0 && PendingTicket == 0) {
      if (BuildSignal_PinBar(sig)) {
         pinExecuted = ExecuteSignal_PinBar(sig);
      }
   }

   if (noLine){
      if (Debug) Print("[MODE=NoLine] Direction=",(CurrentTradeDir==OnlyBuy?"BUY":"SELL"));
      bool posExists = kOnePositionOnly && (CountOpenPositions()>0);

      if (!pinExecuted && UseABLimit && kNoLine_UsePending && !posExists && (new_h1_bar || PendingTicket==0))
         FindLatestPattern_NoLine();

      if (!pinExecuted && UseABMarket && kNoLine_UseMarket && !posExists && PendingTicket==0){
         int barA_shift,barB_shift; double entry,sl,tp;
         if (CheckNewPattern_NoLine(CurrentTradeDir==OnlyBuy,barA_shift,barB_shift,entry,sl,tp)){
            int type=(CurrentTradeDir==OnlyBuy)?OP_BUY:OP_SELL;
            if (IsDirectionAllowed(type)){
               double lot=CalculateLot(entry,sl);
               if (lot>0){
                  string cmt=StringFormat("NoLineMKT|PK:%s",CurrentPattern.Key);
                  int tk=OrderSend(Symbol(),type,lot,entry,kMaxSlippagePoints,sl,tp,cmt,MagicNumber,0,(type==OP_BUY?clrGreen:clrRed));
                  if (tk>0){
                     AddUsedKey(CurrentPattern.Key);
                     if (kOnePositionOnly) CancelAllPendings();
                     if (Debug) Print("[NoLine] Market entry executed. Key=",CurrentPattern.Key);
                  }else{
                     Print("[NoLine] Market entry error: ",GetLastError());
                  }
               }
            }
         }
      }

      if (!pinExecuted && UseDailyExtremeBreak && new_h1_bar && !posExists && PendingTicket==0) {
         UpdateAndCheckDailyExtreme_NoLine();
      }

      ManagePending();
      if (CurrentBreakevenMode==BE_Standard) ManageBreakeven_Standard(); else ManageBreakevenByLine();
      if (new_h1_bar && ShowImpulseDots) DrawNewImpulseDot(1);
      DrawHUD_NoLine();

      if (kOnePositionOnly && CountOpenPositions()==0 && PendingTicket==0){
         CurrentPattern.A_shift=-1; CurrentPattern.B_shift=-1; CurrentPattern.OpenA=0.0;
         CurrentPattern.A_time=0;  CurrentPattern.B_time=0;
         CurrentPattern.Key = "";
         if (Debug) Print("[RESET] No open trades. Search unlocked for new patterns.");
      }

      g_prevBid=Bid; g_prevAsk=Ask; g_prevInited=true;
      return;
   }

   // ======= LINE MODE =======
   UpdateLineLevel();
   if (Level==0.0){ if (Debug) Print("Error: Invalid line level (no SOLID HLine)."); return; }

   bool posExists    = kOnePositionOnly && (CountOpenPositions()>0);
   bool pendingExist = (PendingTicket>0);

   // Pin Bar (с приоритетом)
   if (!pinExecuted && new_h1_bar && !posExists && !pendingExist) {
      if (BuildSignal_PinBar(sig)) {
         pinExecuted = ExecuteSignal_PinBar(sig);
      }
   }

   // Classic pattern -> pending
   if (!pinExecuted && UseABLimit && !posExists && !pendingExist && (new_h1_bar || PendingTicket==0))
      FindLatestPattern();

   // AB-Market
   static bool buy_pattern_executed=false, sell_pattern_executed=false;
   static datetime last_b_close_time_buy=0, last_b_close_time_sell=0;
   if (new_h1_bar){ buy_pattern_executed=false; sell_pattern_executed=false; }

   if (!pinExecuted && UseABMarket && !posExists && !pendingExist){
      int barA_shift,barB_shift; double entry,sl,tp;

      // BUY
      if (!buy_pattern_executed && CurrentTradeDir==OnlyBuy){
         if (CheckNewPattern(true,barA_shift,barB_shift,entry,sl,tp)){
            double openA=iOpen(NULL,PERIOD_H1,barA_shift);
            if (!IsValidByLineGeometry(true,openA)){
               if (Debug) Print("[LINE][AB-MKT] BUY rejected by line geometry");
            }else{
               datetime b_close_time=iTime(NULL,PERIOD_H1,barB_shift);
               if (b_close_time!=last_b_close_time_buy){
                  int type=OP_BUY;
                  if (!IsDirectionAllowed(type)){ if (Debug) Print("Blocked BUY by TradeDir"); }
                  else{
                     double lot=CalculateLot(entry,sl);
                     if (lot>0){
                        string cmt=StringFormat("NewBuyPattern|PK:%s",CurrentPattern.Key);
                        int ticket=OrderSend(Symbol(),type,lot,entry,kMaxSlippagePoints,sl,tp,cmt,MagicNumber,0,clrGreen);
                        if (ticket>0){
                           AddUsedKey(CurrentPattern.Key);
                           if (kOnePositionOnly) CancelAllPendings();
                           PrintFormat("New BUY pattern executed: ticket=%d, entry=%.5f, SL=%.5f, TP=%.5f",ticket,entry,sl,tp);
                           buy_pattern_executed=true; last_b_close_time_buy=b_close_time;
                        }else{
                           Print("Error opening BUY from new pattern: ",GetLastError());
                        }
                     }
                  }
               }
            }
         }
      }

      // SELL
      if (!sell_pattern_executed && CurrentTradeDir==OnlySell){
         if (CheckNewPattern(false,barA_shift,barB_shift,entry,sl,tp)){
            double openA=iOpen(NULL,PERIOD_H1,barA_shift);
            if (!IsValidByLineGeometry(false,openA)){
               if (Debug) Print("[LINE][AB-MKT] SELL rejected by line geometry");
            }else{
               datetime b_close_time=iTime(NULL,PERIOD_H1,barB_shift);
               if (b_close_time!=last_b_close_time_sell){
                  int type=OP_SELL;
                  if (!IsDirectionAllowed(type)){ if (Debug) Print("Blocked SELL by TradeDir"); }
                  else{
                     double lot=CalculateLot(entry,sl);
                     if (lot>0){
                        string cmt=StringFormat("NewSellPattern|PK:%s",CurrentPattern.Key);
                        int ticket=OrderSend(Symbol(),type,lot,entry,kMaxSlippagePoints,sl,tp,cmt,MagicNumber,0,clrRed);
                        if (ticket>0){
                           AddUsedKey(CurrentPattern.Key);
                           if (kOnePositionOnly) CancelAllPendings();
                           PrintFormat("New SELL pattern executed: ticket=%d, entry=%.5f, SL=%.5f, TP=%.5f",ticket,entry,sl,tp);
                           sell_pattern_executed=true; last_b_close_time_sell=b_close_time;
                        }else{
                           Print("Error opening SELL from new pattern: ",GetLastError());
                        }
                     }
                  }
               }
            }
         }
      }
   }

   if (!pinExecuted && UseDailyExtremeBreak && new_h1_bar && !posExists && PendingTicket==0) {
      UpdateAndCheckDailyExtreme_Line();
   }

   ManagePending();
   if (CurrentBreakevenMode==BE_Standard) ManageBreakeven_Standard(); else ManageBreakevenByLine();
   if (new_h1_bar && ShowImpulseDots) DrawNewImpulseDot(1);
   DrawHUD();

   g_prevBid=Bid; g_prevAsk=Ask; g_prevInited=true;
}

//+------------------------------------------------------------------+
//| Pattern check (NoLine market-pattern)                            |
//+------------------------------------------------------------------+
bool CheckNewPattern_NoLine(bool isBuy,int &barA_shift,int &barB_shift,double &entry_price,double &sl,double &tp){
   if (kOnePositionOnly && CountOpenPositions() > 0) return false;

   if (CurrentTradeDir == OnlyBuy && !isBuy) return false;
   if (CurrentTradeDir == OnlySell && isBuy) return false;

   int max_scan = MathMin(MathMax(kNoLine_PatternScanBars,5), iBars(NULL,PERIOD_H1)-1);
   if (max_scan < 3) return false;

   for (int a_shift=2; a_shift<=max_scan; a_shift++){
      int b_shift=a_shift-1;
      datetime b_time = iTime(NULL,PERIOD_H1,b_shift);
      if(!IsInSession(b_time) || !IsToday(b_time)) continue;

      if (!IsImpulseBar(a_shift,true) && !IsImpulseBar(a_shift,false)) continue;

      bool a_is_bull = iClose(NULL,PERIOD_H1,a_shift) > iOpen(NULL,PERIOD_H1,a_shift);
      bool b_is_bull = iClose(NULL,PERIOD_H1,b_shift) > iOpen(NULL,PERIOD_H1,b_shift);
      if (a_is_bull==b_is_bull) continue;

      double lowA=iLow(NULL,PERIOD_H1,a_shift);
      double lowB=iLow(NULL,PERIOD_H1,b_shift);
      double highA=iHigh(NULL,PERIOD_H1,a_shift);
      double highB=iHigh(NULL,PERIOD_H1,b_shift);

      double openA=iOpen(NULL,PERIOD_H1,a_shift);
      double closeA=iClose(NULL,PERIOD_H1,a_shift);
      double closeB=iClose(NULL,PERIOD_H1,b_shift);

      double minA=MathMin(openA,closeA);
      double maxA=MathMax(openA,closeA);

      if (isBuy){
         if(!(lowB<lowA)) continue;
         if (closeB<minA || closeB>maxA) continue;
         if(!IsImpulseBar(b_shift,true)) continue;
      }else{
         if(!(highB>highA)) continue;
         if (closeB<minA || closeB>maxA) continue;
         if(!IsImpulseBar(b_shift,false)) continue;
      }

      datetime a_time=iTime(NULL,PERIOD_H1,a_shift);
      string key=ComposePatternKey(false,isBuy,a_time,b_time);
      if (IsKeyUsed(key)){ if (Debug) Print("[NoLine] Skip market: used key ",key); continue; }

      barA_shift=a_shift; barB_shift=b_shift;

      entry_price = isBuy ? Ask : Bid;

      double sl_dist = SL_Percent * ATR_D1_avg;
      if (isBuy){ sl=NormalizeDouble(entry_price-sl_dist,Digits); tp=NormalizeDouble(entry_price+TP_RR*sl_dist,Digits); }
      else      { sl=NormalizeDouble(entry_price+sl_dist,Digits); tp=NormalizeDouble(entry_price-TP_RR*sl_dist,Digits); }

      double stop_level=MarketInfo(Symbol(),MODE_STOPLEVEL)*Point;
      if (MathAbs(entry_price-sl) < stop_level) sl = isBuy ? NormalizeDouble(entry_price-stop_level,Digits) : NormalizeDouble(entry_price+stop_level,Digits);
      if (MathAbs(tp-entry_price) < stop_level) tp = isBuy ? NormalizeDouble(entry_price+stop_level,Digits) : NormalizeDouble(entry_price-stop_level,Digits);

      CurrentPattern.Key   = key;
      CurrentPattern.A_time= a_time;
      CurrentPattern.B_time= b_time;

      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| NoLine: classic pattern for pending                              |
//+------------------------------------------------------------------+
void FindLatestPattern_NoLine(){
   if (CurrentTradeDir == NoTrade) return;

   int max_bars = MathMin(MathMax(kNoLine_PatternScanBars,5), iBars(NULL,PERIOD_H1)-1);
   if (max_bars < 1) return;

   Pattern new_pattern = { -1, -1, 0.0, 0, 0, "" };

   bool is_buy = (CurrentTradeDir == OnlyBuy);

   for (int b_shift=1; b_shift<=max_bars; b_shift++){
      datetime b_time = iTime(NULL,PERIOD_H1,b_shift);
      if(!IsInSession(b_time) || !IsToday(b_time)) continue;
      int max_a_search = (MaxGapBarsBetweenSignals==0)? max_bars : MathMin(b_shift+MaxGapBarsBetweenSignals,max_bars);
      for (int a_shift=b_shift+1; a_shift<=max_a_search; a_shift++){
         datetime a_time = iTime(NULL,PERIOD_H1,a_shift);
         if(!IsInSession(a_time) || !IsToday(a_time)) continue;
         bool a_impulse = IsImpulseBar(a_shift, !is_buy);
         if (!a_impulse) continue;
         double close_b = iClose(NULL,PERIOD_H1,b_shift);
         double open_a  = iOpen (NULL,PERIOD_H1,a_shift);
         bool ok = is_buy ? (close_b>open_a) : (close_b<open_a);
         if (ok){
            if (CurrentPattern.B_shift==-1 || b_shift<new_pattern.B_shift){
               new_pattern.A_shift=a_shift;
               new_pattern.B_shift=b_shift;
               new_pattern.OpenA  =open_a;
               new_pattern.A_time =a_time;
               new_pattern.B_time =b_time;
               new_pattern.Key    =ComposePatternKey(false,is_buy,new_pattern.A_time,new_pattern.B_time);
            }
            break;
         }
      }
   }

   if (new_pattern.B_shift!=-1){
      if (IsKeyUsed(new_pattern.Key)){ if (Debug) Print("[NoLine] Skip pending: used key ",new_pattern.Key); return; }

      CurrentPattern = new_pattern;
      double entry_preview = NormalizeDouble(new_pattern.OpenA,Digits);

      double stop_level=MarketInfo(Symbol(),MODE_STOPLEVEL)*Point;
      double freeze_lvl=MarketInfo(Symbol(),MODE_FREEZELEVEL)*Point;
      double min_dist  = MathMax(stop_level,freeze_lvl);

      if (CurrentTradeDir==OnlyBuy) entry_preview=MathMin(entry_preview,Ask - min_dist);
      else                          entry_preview=MathMax(entry_preview,Bid + min_dist);

      entry_preview = NormalizeDouble(entry_preview,Digits);
      DrawPatternMarkers(CurrentPattern,entry_preview);
      if (kNoLine_UsePending) PlaceOrReplacePending_NoLine();
   }
}
void PlaceOrReplacePending_NoLine(){
   if (CurrentPattern.A_shift==-1) return;
   if (kOnePositionOnly && CountOpenPositions()>0){ if (Debug) Print("[NoLine] Skip pending: open position exists."); return; }

   if (IsKeyUsed(CurrentPattern.Key)){ if (Debug) Print("[NoLine] Skip pending place: used key ",CurrentPattern.Key); return; }

   double entry = NormalizeDouble(CurrentPattern.OpenA,Digits);
   int type = (CurrentTradeDir==OnlyBuy)? OP_BUYLIMIT : OP_SELLLIMIT;
   if (!IsDirectionAllowed(type)){ if (Debug) Print("[NoLine] Blocked pending by TradeDir"); return; }

   double stop_level=MarketInfo(Symbol(),MODE_STOPLEVEL)*Point;
   double freeze_lvl=MarketInfo(Symbol(),MODE_FREEZELEVEL)*Point;
   double min_dist  = MathMax(stop_level,freeze_lvl);

   if (CurrentTradeDir==OnlyBuy){
      entry = MathMin(entry,Ask - min_dist);
      if (entry > Ask - min_dist){ if (Debug) Print("[NoLine] BuyLimit too close to Stop/Freeze"); return; }
   }else{
      entry = MathMax(entry,Bid + min_dist);
      if (entry < Bid + min_dist){ if (Debug) Print("[NoLine] SellLimit too close to Stop/Freeze"); return; }
   }
   entry=NormalizeDouble(entry,Digits);

   double sl_dist = SL_Percent * ATR_D1_avg;
   double tp_dist = TP_RR * sl_dist;
   double sl = NormalizeDouble((CurrentTradeDir==OnlyBuy)? entry - sl_dist : entry + sl_dist,Digits);
   double tp = NormalizeDouble((CurrentTradeDir==OnlyBuy)? entry + tp_dist : entry - tp_dist,Digits);

   double min_stop=MarketInfo(Symbol(),MODE_STOPLEVEL)*Point;
   if (MathAbs(sl-entry)<min_stop){
      sl = (CurrentTradeDir==OnlyBuy)? NormalizeDouble(entry-min_stop,Digits) : NormalizeDouble(entry+min_stop,Digits);
      if (Debug) Print("[NoLine] SL adjusted to StopLevel.");
   }
   if (MathAbs(tp-entry)<min_stop){
      tp = (CurrentTradeDir==OnlyBuy)? NormalizeDouble(entry+min_stop,Digits) : NormalizeDouble(entry-min_stop,Digits);
      if (Debug) Print("[NoLine] TP adjusted to StopLevel.");
   }

   double lot = CalculateLot(entry,sl); if (lot==0.0) return;
// ⛔️ DAILY LOSS LIMIT — проверка перед установкой pending
if(!CanTradeToday())
{
   Print("[DAILY-LOSS-LIMIT] Pending placement blocked. losses=",
         CountLosingTradesToday(), " limit=", MaxLosingTradesPerDay);
   return;
}
   if (PendingTicket>0){
      if (!kReplacePendingOnNewPattern) return;
      if (!OrderSelect(PendingTicket,SELECT_BY_TICKET)){ PendingTicket=0; PendingPatternKey = ""; }
      else{
         double prev_entry=OrderOpenPrice();
         bool better = (CurrentTradeDir==OnlyBuy && entry<=prev_entry-Point) || (CurrentTradeDir==OnlySell && entry>=prev_entry+Point);
         if (!better){ if (Debug) Print("[NoLine] New pattern not better for replace."); return; }
         if (!OrderDelete(PendingTicket)){ Print("[NoLine] Error deleting pending: ",GetLastError()); return; }
         PendingTicket=0;
         PendingPatternKey = "";
      }
   }

   string cmt=StringFormat("TargetPoint(NoLine)|PK:%s",CurrentPattern.Key);
   int ticket=OrderSend(Symbol(),type,lot,entry,kMaxSlippagePoints,sl,tp,cmt,MagicNumber,0,clrBlue);
   if (ticket>0){
      PendingTicket=ticket;
      PendingPlaceTime=TimeCurrent();
      PendingPlaceH1BarIndex=iBars(NULL,PERIOD_H1)-1;
      PendingPatternKey = CurrentPattern.Key;
      if (Debug) Print("[NoLine] Placed pending: ",(type==OP_BUYLIMIT?"BuyLimit":"SellLimit")," at ",DoubleToStr(entry,Digits)," | ",PendingPatternKey);
   }else{
      Print("[NoLine] Error placing pending: ",GetLastError());
   }
}

//+------------------------------------------------------------------+
//| Pattern check (A impulse + B opposite, line-mode)                |
//+------------------------------------------------------------------+
bool CheckNewPattern(bool isBuy,int &barA_shift,int &barB_shift,double &entry_price,double &sl,double &tp){
   if (kOnePositionOnly && (CountOpenPositions()>0 || CountPendings()>0)) return false;

   if (CurrentTradeDir==OnlyBuy && !isBuy) return false;
   if (CurrentTradeDir==OnlySell && isBuy) return false;

   if (Level==0.0) return false;

   int max_scan = MathMin(SearchWindowBars, iBars(NULL,PERIOD_H1)-1);
   if (max_scan < 2) return false;

   for (int a_shift=2; a_shift<=max_scan; a_shift++){
      int b_shift=a_shift-1;
      datetime b_time = iTime(NULL,PERIOD_H1,b_shift);
      if(!IsInSession(b_time) || !IsToday(b_time)) continue;

      if (!IsImpulseBar(a_shift,true) && !IsImpulseBar(a_shift,false)) continue;

      bool a_is_bull = iClose(NULL,PERIOD_H1,a_shift) > iOpen(NULL,PERIOD_H1,a_shift);
      bool b_is_bull = iClose(NULL,PERIOD_H1,b_shift) > iOpen(NULL,PERIOD_H1,b_shift);
      if (a_is_bull==b_is_bull) continue;

      double lowA   = iLow (NULL,PERIOD_H1,a_shift);
      double lowB   = iLow (NULL,PERIOD_H1,b_shift);
      double highA  = iHigh(NULL,PERIOD_H1,a_shift);
      double highB  = iHigh(NULL,PERIOD_H1,b_shift);

      double openA  = iOpen (NULL,PERIOD_H1,a_shift);
      double closeA = iClose(NULL,PERIOD_H1,a_shift);
      double closeB = iClose(NULL,PERIOD_H1,b_shift);

      double minA = MathMin(openA,closeA);
      double maxA = MathMax(openA,closeA);

      if (isBuy){
         if(!(lowB<lowA)) continue;
         if (closeB<minA || closeB>maxA) continue;
         if(!IsImpulseBar(b_shift,true)) continue;
      }else{
         if(!(highB>highA)) continue;
         if (closeB<minA || closeB>maxA) continue;
         if(!IsImpulseBar(b_shift,false)) continue;
      }

      datetime a_time=iTime(NULL,PERIOD_H1,a_shift);
      string key=ComposePatternKey(true,isBuy,a_time,b_time);
      if (IsKeyUsed(key)){ if (Debug) Print("[LINE] Skip market: used key ",key); continue; }

      double refPrice = openA;
      if (!IsValidByLineGeometry(isBuy, refPrice)) {
         double distATR = (ATR_D1_avg>0)? MathAbs(refPrice - Level) / ATR_D1_avg : -1;
         if (Debug) PrintFormat("[LINE][AB-MKT] Candidate rejected by line geometry (dist=%.2f ATR).", distATR);
         continue;
      }

      barA_shift=a_shift;
      barB_shift=b_shift;

      entry_price = isBuy ? Ask : Bid;

      double sl_dist = SL_Percent * ATR_D1_avg;
      if (isBuy){ sl=NormalizeDouble(entry_price-sl_dist,Digits); tp=NormalizeDouble(entry_price+TP_RR*sl_dist,Digits); }
      else      { sl=NormalizeDouble(entry_price+sl_dist,Digits); tp=NormalizeDouble(entry_price-TP_RR*sl_dist,Digits); }

      double stop_level=MarketInfo(Symbol(),MODE_STOPLEVEL)*Point;
      if (MathAbs(entry_price-sl) < stop_level) sl = isBuy ? NormalizeDouble(entry_price-stop_level,Digits) : NormalizeDouble(entry_price+stop_level,Digits);
      if (MathAbs(tp-entry_price) < stop_level) tp = isBuy ? NormalizeDouble(entry_price+stop_level,Digits) : NormalizeDouble(entry_price-stop_level,Digits);

      CurrentPattern.Key   = key;
      CurrentPattern.A_time= a_time;
      CurrentPattern.B_time= b_time;

      return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| Update horizontal line level (SOLID only)                        |
//+------------------------------------------------------------------+
void UpdateLineLevel(){
   double new_level=0.0;
   string sel_name="";
   bool   found=false;

   int total=ObjectsTotal();

   if (total>0){
      if (kHLinePickMode==NearestToPrice){
         double mid=(Ask+Bid)/2.0;
         double best=DBL_MAX;
         for (int i=0;i<total;i++){
            string name=ObjectName(i);
            if (ObjectType(name)!=OBJ_HLINE) continue;

            if (StringFind(name,"TP_")==0) continue; // служебные
            int style=(int)ObjectGetInteger(0,name,OBJPROP_STYLE);
            if (style!=STYLE_SOLID) continue;

            double price=ObjectGetDouble(0,name,OBJPROP_PRICE,0);
            if (price==0.0) continue;
            double dist=MathAbs(price-mid);
            if (dist<best){ best=dist; new_level=price; sel_name=name; found=true; }
         }
      }else{
         for (int i=total-1;i>=0;i--){
            string name=ObjectName(i);
            if (ObjectType(name)!=OBJ_HLINE) continue;
            if (StringFind(name,"TP_")==0) continue;
            int style=(int)ObjectGetInteger(0,name,OBJPROP_STYLE);
            if (style!=STYLE_SOLID) continue;

            double price=ObjectGetDouble(0,name,OBJPROP_PRICE,0);
            if (price==0.0) continue;
            new_level=price; sel_name=name; found=true;
            break;
         }
      }
   }else{
      if (Debug) Print("No SOLID HLines on chart.");
   }

   if (!found){ if (Debug) Print("No valid SOLID trade HLine found. Keeping previous Level."); return; }

   Level=NormalizeDouble(new_level,Digits);
   SelectedHLineName=sel_name;
}

//+------------------------------------------------------------------+
//| Calculate ATR averages                                           |
//+------------------------------------------------------------------+
void CalculateATRs(){
   int h1need=MathMax(H1_AvgRangePeriod,1)+1;
   int d1need=MathMax(D1_AvgRangePeriod,1)+1;
   if (iBars(NULL,PERIOD_H1)<h1need || iBars(NULL,PERIOD_D1)<d1need) return;

   double sum_h1=0.0;
   for (int i=1;i<=H1_AvgRangePeriod;i++)
      sum_h1 += (iHigh(NULL,PERIOD_H1,i) - iLow(NULL,PERIOD_H1,i));
   ATR_H1_avg = sum_h1 / MathMax(H1_AvgRangePeriod,1);

   double sum_d1=0.0;
   for (int i=1;i<=D1_AvgRangePeriod;i++)
      sum_d1 += (iHigh(NULL,PERIOD_D1,i) - iLow(NULL,PERIOD_D1,i));
   ATR_D1_avg = sum_d1 / MathMax(D1_AvgRangePeriod,1);
}

//+------------------------------------------------------------------+
//| Impulse bar check (thirds rule)                                  |
//+------------------------------------------------------------------+
bool IsImpulseBar(int shift,bool is_up){
   if (ATR_H1_avg<=0) return false;

   double high  = iHigh (NULL,PERIOD_H1,shift);
   double low   = iLow  (NULL,PERIOD_H1,shift);
   double open  = iOpen (NULL,PERIOD_H1,shift);
   double close = iClose(NULL,PERIOD_H1,shift);

   double range = high - low;
   if (range<=0.0) return false;
   if (range < MinImpulseATR * ATR_H1_avg) return false;

   double one_third = range/3.0;

   if (is_up){
      if (close<=open) return false;
      if (!(open <= low  + one_third))  return false;
      if (!(close>= high - one_third))  return false;
   }else{
      if (close>=open) return false;
      if (!(open >= high - one_third))  return false;
      if (!(close<= low  + one_third))  return false;
   }
   return true;
}

//+------------------------------------------------------------------+
//| Find latest pattern in current day (pending, line mode)          |
//+------------------------------------------------------------------+
void FindLatestPattern(){
   if (CurrentTradeDir == NoTrade) return;
   if (Level==0.0) return;

   int max_bars = MathMin(SearchWindowBars, iBars(NULL,PERIOD_H1)-1);
   if (max_bars < 1) return;

   Pattern new_pattern = { -1, -1, 0.0, 0, 0, "" };
   bool is_buy = (CurrentTradeDir==OnlyBuy);

   for (int b_shift=1; b_shift<=max_bars; b_shift++){
      datetime b_time = iTime(NULL,PERIOD_H1,b_shift);
      if(!IsInSession(b_time) || !IsToday(b_time)) continue;
      int max_a_search = (MaxGapBarsBetweenSignals==0)? max_bars : MathMin(b_shift+MaxGapBarsBetweenSignals,max_bars);
      for (int a_shift=b_shift+1; a_shift<=max_a_search; a_shift++){
         datetime a_time = iTime(NULL,PERIOD_H1,a_shift);
         if(!IsInSession(a_time) || !IsToday(a_time)) continue;
         bool a_impulse = IsImpulseBar(a_shift, !is_buy);
         if (!a_impulse) continue;
         double close_b = iClose(NULL,PERIOD_H1,b_shift);
         double open_a  = iOpen (NULL,PERIOD_H1,a_shift);
         bool ok = is_buy ? (close_b>open_a) : (close_b<open_a);
         if (ok){
            double refPrice = open_a;
            if (!IsValidByLineGeometry(is_buy, refPrice)) {
               double distATR = (ATR_D1_avg>0)? MathAbs(refPrice - Level) / ATR_D1_avg : -1;
               if (Debug) PrintFormat("[LINE][PENDING] Candidate rejected by line geometry (dist=%.2f ATR).", distATR);
               continue;
            }

            if (CurrentPattern.B_shift==-1 || b_shift<new_pattern.B_shift){
               new_pattern.A_shift=a_shift;
               new_pattern.B_shift=b_shift;
               new_pattern.OpenA  =open_a;
               new_pattern.A_time =a_time;
               new_pattern.B_time =b_time;
               new_pattern.Key    =ComposePatternKey(true,is_buy,new_pattern.A_time,new_pattern.B_time);
            }
            break;
         }
      }
   }

   if (new_pattern.B_shift!=-1){
      if (IsKeyUsed(new_pattern.Key)){ if (Debug) Print("[LINE] Skip pending: used key ",new_pattern.Key); return; }

      CurrentPattern = new_pattern;
      double entry_preview=NormalizeDouble(new_pattern.OpenA,Digits);

      double stop_level=MarketInfo(Symbol(),MODE_STOPLEVEL)*Point;
      double freeze_lvl=MarketInfo(Symbol(),MODE_FREEZELEVEL)*Point;
      double min_dist=MathMax(stop_level,freeze_lvl);

      if (CurrentTradeDir==OnlyBuy) entry_preview=MathMin(entry_preview,Ask - min_dist);
      else entry_preview=MathMax(entry_preview,Bid + min_dist);

      entry_preview = NormalizeDouble(entry_preview,Digits);
      DrawPatternMarkers(CurrentPattern,entry_preview);
      PlaceOrReplacePending();
   }
}

//+------------------------------------------------------------------+
//| Place or replace pending (line mode)                             |
//+------------------------------------------------------------------+
void PlaceOrReplacePending(){
   if (CurrentPattern.A_shift==-1) return;
   if (kOnePositionOnly && CountOpenPositions()>0){ if (Debug) Print("Skip pending: open position exists (OnePositionOnly)."); return; }

   if (IsKeyUsed(CurrentPattern.Key)){ if (Debug) Print("[LINE] Skip pending place: used key ",CurrentPattern.Key); return; }

   double entry = NormalizeDouble(CurrentPattern.OpenA,Digits);

   bool is_buy = (CurrentTradeDir==OnlyBuy);
   if (!IsValidByLineGeometry(is_buy, entry)){
      if (Debug) Print("[LINE][AB-LIMIT] Rejected by line geometry");
      return;
   }

   int type = is_buy ? OP_BUYLIMIT : OP_SELLLIMIT;
   if (!IsDirectionAllowed(type)){ if (Debug) Print("Blocked pending by TradeDir"); return; }

   double stop_level=MarketInfo(Symbol(),MODE_STOPLEVEL)*Point;
   double freeze_lvl=MarketInfo(Symbol(),MODE_FREEZELEVEL)*Point;
   double min_dist=MathMax(stop_level,freeze_lvl);

   if (is_buy){
      entry=MathMin(entry,Ask - min_dist);
      if (entry>Ask - min_dist){ if (Debug) Print("BuyLimit too close to Stop/Freeze level"); return; }
   }else{
      entry=MathMax(entry,Bid + min_dist);
      if (entry< Bid + min_dist){ if (Debug) Print("SellLimit too close to Stop/Freeze level"); return; }
   }
   entry=NormalizeDouble(entry,Digits);

   double sl_dist = SL_Percent * ATR_D1_avg;
   double tp_dist = TP_RR * sl_dist;
   double sl = NormalizeDouble(is_buy ? entry - sl_dist : entry + sl_dist,Digits);
   double tp = NormalizeDouble(is_buy ? entry + tp_dist : entry - tp_dist,Digits);

   double min_stop=MarketInfo(Symbol(),MODE_STOPLEVEL)*Point;
   if (MathAbs(sl-entry)<min_stop){
      sl = is_buy ? NormalizeDouble(entry-min_stop,Digits) : NormalizeDouble(entry+min_stop,Digits);
      if (Debug) Print("SL adjusted to StopLevel.");
   }
   if (MathAbs(tp-entry)<min_stop){
      tp = is_buy ? NormalizeDouble(entry+min_stop,Digits) : NormalizeDouble(entry-min_stop,Digits);
      if (Debug) Print("TP adjusted to StopLevel.");
   }

   double lot = CalculateLot(entry,sl); if (lot==0.0) return;
// ⛔ DAILY LOSS LIMIT — блокируем выставление pending в этот день
if(!CanTradeToday())
{
   Print("[DAILY-LOSS-LIMIT] Pending (line mode) blocked. losses=",
         CountLosingTradesToday(), " limit=", MaxLosingTradesPerDay);
   return;
}

   if (PendingTicket>0){
      if (!kReplacePendingOnNewPattern) return;
      if (!OrderSelect(PendingTicket,SELECT_BY_TICKET)){ PendingTicket=0; PendingPatternKey = ""; return; }
      double prev_entry=OrderOpenPrice();
      bool better=(is_buy && entry<=prev_entry-Point) || (!is_buy && entry>=prev_entry+Point);
      if (!better){ if (Debug) Print("New pattern not better for replace."); return; }
      if (!OrderDelete(PendingTicket)){ Print("Error deleting pending: ",GetLastError()); return; }
      PendingTicket=0; PendingPatternKey = "";
   }

   string cmt=StringFormat("TargetPoint|PK:%s",CurrentPattern.Key);
   int ticket=OrderSend(Symbol(),type,lot,entry,kMaxSlippagePoints,sl,tp,cmt,MagicNumber,0,clrBlue);
   if (ticket>0){
      PendingTicket=ticket;
      PendingPlaceTime=TimeCurrent();
      PendingPlaceH1BarIndex=iBars(NULL,PERIOD_H1)-1;
      PendingPatternKey = CurrentPattern.Key;
      Print("Placed pending: ",(type==OP_BUYLIMIT?"BuyLimit":"SellLimit")," at ",entry," | ",PendingPatternKey);
   }else{
      Print("Error placing pending: ",GetLastError());
   }
}

//+------------------------------------------------------------------+
//| Calculate lot size                                               |
//+------------------------------------------------------------------+
double ValuePerPoint_1lot(){
   double tick_value=MarketInfo(Symbol(),MODE_TICKVALUE);
   double tick_size =MarketInfo(Symbol(),MODE_TICKSIZE);
   if (tick_size<=0.0) tick_size=Point;
   return tick_value*(Point/tick_size);
}
double CalculateLot(double entry,double sl){
   double balance=AccountBalance();
   double risk_money=balance*RiskPercent/100.0;
   double sl_dist=MathAbs(entry-sl);
   double sl_points=sl_dist/Point;
   if (sl_points<=0){ Print("Error: Invalid SL points."); return 0.0; }
   double vpp=ValuePerPoint_1lot();
   if (vpp<=0){ Print("Error: invalid ValuePerPoint"); return 0.0; }
   double lot=risk_money/(sl_points*vpp);
   double min_lot=MarketInfo(Symbol(),MODE_MINLOT);
   double max_lot=MarketInfo(Symbol(),MODE_MAXLOT);
   double lot_step=MarketInfo(Symbol(),MODE_LOTSTEP);
   lot=MathFloor(lot/lot_step)*lot_step;
   lot=MathMax(min_lot,MathMin(max_lot,lot));
   if (lot<min_lot){
      PrintFormat("Warning: computed lot %.4f < min %.2f, using MinLot.",lot,min_lot);
      lot=min_lot;
   }
   return lot;
}

//+------------------------------------------------------------------+
//| Manage pending (expiry = MaxGapBarsBetweenSignals)               |
//+------------------------------------------------------------------+
void ManagePending(){
   if (kOnePositionOnly && CountOpenPositions()>0){
      if (PendingTicket>0 && OrderSelect(PendingTicket,SELECT_BY_TICKET) &&
          (OrderType()==OP_BUYLIMIT || OrderType()==OP_SELLLIMIT || OrderType()==OP_BUYSTOP || OrderType()==OP_SELLSTOP)){
         if (!OrderDelete(PendingTicket)) Print("ManagePending: fail delete pending ",GetLastError());
         PendingTicket=0;
         PendingPatternKey = "";
      }
      CancelAllPendings();
      return;
   }

   if (PendingTicket<=0) return;
   if (!OrderSelect(PendingTicket,SELECT_BY_TICKET)){ PendingTicket=0; PendingPatternKey = ""; return; }

   if (OrderType()!=OP_BUYLIMIT && OrderType()!=OP_SELLLIMIT){
      string k=PendingPatternKey;
      if (k==""){
         string cmt=OrderComment();
         if (!TryParseKeyFromComment(cmt,k)) k="";
      }
      if (k!="") AddUsedKey(k);

      PendingTicket=0;
      PendingPatternKey = "";
      Print("Pending activated to position.");
      return;
   }

   int bars_since_place = iBars(NULL,PERIOD_H1) - PendingPlaceH1BarIndex;
   int expiryBars = MaxGapBarsBetweenSignals;
   if (Debug) PrintFormat("[ManagePending] Ticket=%d, Bars since place=%d, Expiry bars=%d, H1 bars=%d, PlaceIndex=%d",
                         PendingTicket, bars_since_place, expiryBars, iBars(NULL,PERIOD_H1), PendingPlaceH1BarIndex);
   if (expiryBars>0 && bars_since_place >= expiryBars){
      string k = PendingPatternKey;
      if (k != "") AddUsedKey(k);
      if (OrderDelete(PendingTicket)) Print("Pending expired and deleted. Pattern key added to used: ", k);
      else Print("Error deleting expired pending: ", GetLastError());
      PendingTicket=0;
      PendingPatternKey = "";
   }
}

//+------------------------------------------------------------------+
//| Manage breakeven (standard)                                      |
//+------------------------------------------------------------------+
void ManageBreakeven_Standard(){
   double mult=2.0; // прежняя логика, BreakevenSLMultiplier упразднен из меню; можно вынести в жесткую настройку
   for (int i=OrdersTotal()-1;i>=0;i--){
      if (!OrderSelect(i,SELECT_BY_POS,MODE_TRADES)) continue;
      if (OrderSymbol()!=Symbol() || OrderMagicNumber()!=MagicNumber) continue;
      if (OrderType()!=OP_BUY && OrderType()!=OP_SELL) continue;

      int ticket=OrderTicket();
      if (IsBEDone(ticket)) continue;

      double entry=OrderOpenPrice();
      double sl   =OrderStopLoss();
      double sl_dist = MathAbs(entry-sl);
      double sl_points = sl_dist/Point;
      double offset=kBreakevenOffsetPoints*Point;

      bool trigger=false;
      if (OrderType()==OP_BUY){
         if ((Bid-entry)/Point >= sl_points*mult){ trigger=true; sl=NormalizeDouble(entry+offset,Digits); }
      }else{
         if ((entry-Ask)/Point >= sl_points*mult){ trigger=true; sl=NormalizeDouble(entry-offset,Digits); }
      }

      if (trigger){
         double tp=OrderTakeProfit();
         if (OrderModify(ticket,entry,sl,tp,0,clrGreen)){
            Print("Breakeven set for ticket ",ticket);
            AddBEDone(ticket);
         }else{
            Print("Error setting breakeven: ",GetLastError());
         }
      }
   }
}
bool IsBEDone(int ticket){ for (int i=0;i<BE_DoneCount;i++){ if (BE_DoneTickets[i]==ticket) return true; } return false; }
void AddBEDone(int ticket){ if (BE_DoneCount<ArraySize(BE_DoneTickets)){ BE_DoneTickets[BE_DoneCount]=ticket; BE_DoneCount++; } }
bool WasJustActivated(int ticket,int seconds_grace=2){ if(!OrderSelect(ticket,SELECT_BY_TICKET)) return false; return (TimeCurrent()-OrderOpenTime()<=seconds_grace); }
bool CrossedUp(double level){ if(!g_prevInited) return false; return (g_prevBid<level && Bid>=level); }
bool CrossedDown(double level){ if(!g_prevInited) return false; return (g_prevAsk>level && Ask<=level); }

//+------------------------------------------------------------------+
//| Impulse Dots Visualization                                       |
//+------------------------------------------------------------------+
string GetBarId(int shift){
   datetime t = iTime(NULL, PERIOD_H1, shift);
   return IntegerToString(t);
}
void DrawAllImpulseDots(){
   if (!ShowImpulseDots) return;
   string prefix="ImpulseDot_";
   for (int i=ObjectsTotal()-1; i>=0; i--){
      string name = ObjectName(i);
      if (StringFind(name, prefix) == 0) ObjectDelete(name);
   }
   int max_shift = MathMin(ImpulseScanBars, iBars(NULL, PERIOD_H1)-1);
   for (int shift=1; shift<=max_shift; shift++){
      datetime t = iTime(NULL, PERIOD_H1, shift);
      string bar_id = GetBarId(shift);

      if (IsImpulseBar(shift, true)){
         double price = iLow(NULL, PERIOD_H1, shift) + (-ImpulseOffsetPoints) * Point;
         string name = prefix + "bull_" + bar_id;
         ObjectCreate(name, OBJ_ARROW, 0, t, price);
         ObjectSet(name, OBJPROP_ARROWCODE, 233);
         ObjectSet(name, OBJPROP_COLOR, kImpulseBullDotColor);
         ObjectSet(name, OBJPROP_WIDTH, 1);
         ObjectSet(name, OBJPROP_BACK, false);
      }
      if (IsImpulseBar(shift, false)){
         double price = iHigh(NULL, PERIOD_H1, shift) + (ImpulseOffsetPoints) * Point;
         string name = prefix + "bear_" + bar_id;
         ObjectCreate(name, OBJ_ARROW, 0, t, price);
         ObjectSet(name, OBJPROP_ARROWCODE, 234);
         ObjectSet(name, OBJPROP_COLOR, kImpulseBearDotColor);
         ObjectSet(name, OBJPROP_WIDTH, 1);
         ObjectSet(name, OBJPROP_BACK, false);
      }
   }
   ChartRedraw();
}
void DrawNewImpulseDot(int shift){
   if (!ShowImpulseDots) return;
   if (shift != 1) return;

   datetime t = iTime(NULL, PERIOD_H1, shift);
   string bar_id = GetBarId(shift);
   string prefix = "ImpulseDot_";

   if (IsImpulseBar(shift, true)){
      double price = iLow(NULL, PERIOD_H1, shift) + (-ImpulseOffsetPoints) * Point;
      string name = prefix + "bull_" + bar_id;
      if (ObjectFind(0, name) < 0){
         ObjectCreate(name, OBJ_ARROW, 0, t, price);
         ObjectSet(name, OBJPROP_ARROWCODE, 233);
         ObjectSet(name, OBJPROP_COLOR, kImpulseBullDotColor);
         ObjectSet(name, OBJPROP_WIDTH, 1);
         ObjectSet(name, OBJPROP_BACK, false);
      }
   }
   if (IsImpulseBar(shift, false)){
      double price = iHigh(NULL, PERIOD_H1, shift) + (ImpulseOffsetPoints) * Point;
      string name = prefix + "bear_" + bar_id;
      if (ObjectFind(0, name) < 0){
         ObjectCreate(name, OBJ_ARROW, 0, t, price);
         ObjectSet(name, OBJPROP_ARROWCODE, 234);
         ObjectSet(name, OBJPROP_COLOR, kImpulseBearDotColor);
         ObjectSet(name, OBJPROP_WIDTH, 1);
         ObjectSet(name, OBJPROP_BACK, false);
      }
   }
   ChartRedraw();
}

//+------------------------------------------------------------------+
//| Viz                                                              |
//+------------------------------------------------------------------+
void DrawVLine(string name,datetime t,color c){ if(ObjectFind(name)>=0) ObjectDelete(name); ObjectCreate(name,OBJ_VLINE,0,t,0); ObjectSet(name,OBJPROP_COLOR,c); ObjectSet(name,OBJPROP_STYLE,STYLE_DOT); }
void DrawArrow(string name,datetime t,double price,color c,int code){ if(ObjectFind(name)>=0) ObjectDelete(name); ObjectCreate(name,OBJ_ARROW,0,t,price); ObjectSet(name,OBJPROP_COLOR,c); ObjectSet(name,OBJPROP_ARROWCODE,code); }
void DrawText(string name,datetime t,double price,string txt,color c){ if(ObjectFind(name)>=0) ObjectDelete(name); ObjectCreate(name,OBJ_TEXT,0,t,price); ObjectSetText(name,txt,8,"Arial",c); }

void DrawPatternMarkers(const Pattern &p,double entry){
   string base=StringFormat("TP_%s_",Symbol());
   DrawVLine(base+"A_v",p.A_time,clrDodgerBlue);
   DrawVLine(base+"B_v",p.B_time,clrOrangeRed);
   DrawArrow(base+"A_arrow",p.A_time,p.OpenA,clrDodgerBlue,241);
   DrawText (base+"A_txt",  p.A_time,p.OpenA,"A (open)",clrDodgerBlue);
   double closeB=iClose(NULL,PERIOD_H1,p.B_shift);
   DrawArrow(base+"B_arrow",p.B_time,closeB,clrOrangeRed,241);
   DrawText (base+"B_txt",  p.B_time,closeB,"B (close)",clrOrangeRed);

   string el=base+"Entry";
   if (ObjectFind(el)>=0) ObjectDelete(el);
   datetime t0=Time[0];
   datetime t1=t0+Period()*60;
   ObjectCreate(0,el,OBJ_TREND,0,t0,entry,t1,entry);
   ObjectSetInteger(0,el,OBJPROP_RAY,true);
   ObjectSetInteger(0,el,OBJPROP_STYLE,STYLE_DASHDOT);
   ObjectSetInteger(0,el,OBJPROP_WIDTH,1);
   ObjectSetInteger(0,el,OBJPROP_COLOR,clrLime);
   ObjectSetString (0,el,OBJPROP_TEXT,"Entry");
}

void DrawSignalMarkers(const SignalCandle &s, bool isBuy){
   string base=StringFormat("TP_Signal_%s_",Symbol());
   color c = isBuy ? clrDodgerBlue : clrOrangeRed;
   DrawVLine(base+"Signal_v",s.time,c);
   DrawArrow(base+"Signal_arrow",s.time,s.entry_level,c,241);
   DrawText (base+"Signal_txt", s.time,s.entry_level,"Signal Entry",c);

   string el=base+"Entry";
   if (ObjectFind(el)>=0) ObjectDelete(el);
   datetime t0=Time[0];
   datetime t1=t0+Period()*60;
   ObjectCreate(0,el,OBJ_TREND,0,t0,s.entry_level,t1,s.entry_level);
   ObjectSetInteger(0,el,OBJPROP_RAY,true);
   ObjectSetInteger(0,el,OBJPROP_STYLE,STYLE_DASHDOT);
   ObjectSetInteger(0,el,OBJPROP_WIDTH,1);
   ObjectSetInteger(0,el,OBJPROP_COLOR,clrLime);
   ObjectSetString (0,el,OBJPROP_TEXT,"Signal Entry");
}

double PipSize(){ return (Digits==5 || Digits==3) ? 10.0*Point : Point; }
int ToPips(double price_distance){ double pip=PipSize(); return (int)MathRound(price_distance/pip); }

void DrawLabel(string name,int corner,int x,int y,string text,int fontsize,color c){
   if (ObjectFind(name)<0) ObjectCreate(name,OBJ_LABEL,0,0,0);
   ObjectSet(name,OBJPROP_CORNER,corner);
   ObjectSet(name,OBJPROP_XDISTANCE,x);
   ObjectSet(name,OBJPROP_YDISTANCE,y);
   ObjectSet(name,OBJPROP_FONTSIZE,fontsize);
   ObjectSetText(name,text,fontsize,"Arial",c);
   ObjectSet(name,OBJPROP_COLOR,c);
   ObjectSet(name,OBJPROP_BACK,FALSE);
}

void DrawHUD(){
   string dir=(CurrentTradeDir==OnlyBuy)?"BUY":(CurrentTradeDir==OnlySell)?"SELL":"NO TRADE";
   string beMode = (CurrentBreakevenMode == BE_Standard) ? "Standard" : "ByDashedHLine";
   int fs=12;
   int chart_w=(int)ChartGetInteger(0,CHART_WIDTH_IN_PIXELS,0);
   string dirTx=StringFormat("Direction: %s | BE: %s",dir,beMode);
   int approx_w=(int)(StringLen(dirTx)*(fs*0.6));
   int x_center=MathMax(0,chart_w/2 - approx_w/2);
   DrawLabel("TP_HUD_DIR",0,x_center,10,dirTx,fs+2,clrBlack);

   int atr_h1_pips=ToPips(ATR_H1_avg);
   int atr_d1_pips=ToPips(ATR_D1_avg);
   string l_atr=StringFormat("ATR(D1) %d pp    ATR(H1) %d pp",atr_d1_pips,atr_h1_pips);
   DrawLabel("TP_HUD_ATR",2,10,10,l_atr,fs,clrBlack);

   ObjectDelete("TP_HUD_2"); ObjectDelete("TP_HUD_3"); ObjectDelete("TP_HUD_BL");
   ObjectDelete("TP_HUD_1"); ObjectDelete("TP_HUD_4"); ObjectDelete("TP_HUD_5"); ObjectDelete("TP_HUD_6");
   ChartRedraw();
}
void DrawHUD_NoLine(){
   string dir=(CurrentTradeDir==OnlyBuy)?"BUY":(CurrentTradeDir==OnlySell)?"SELL":"NO TRADE";
   string beMode = (CurrentBreakevenMode == BE_Standard) ? "Standard" : "ByDashedHLine";
   int fs=12;
   int chart_w=(int)ChartGetInteger(0,CHART_WIDTH_IN_PIXELS,0);
   string dirTx=StringFormat("Direction: %s  (NoLine) | BE: %s",dir,beMode);
   int approx_w=(int)(StringLen(dirTx)*(fs*0.6));
   int x_center=MathMax(0,chart_w/2 - approx_w/2);
   DrawLabel("TP_HUD_DIR",0,x_center,10,dirTx,fs+2,clrBlack);

   int atr_h1_pips=ToPips(ATR_H1_avg);
   int atr_d1_pips=ToPips(ATR_D1_avg);
   string l_atr=StringFormat("ATR(D1) %d pp    ATR(H1) %d pp",atr_d1_pips,atr_h1_pips);
   DrawLabel("TP_HUD_ATR",2,10,10,l_atr,fs,clrBlack);

   ObjectDelete("DBG_2"); ObjectDelete("DBG_3");
   ChartRedraw();
}

// ==================================================================
// ============== DAILY EXTREME BREAK (FIXED LOGIC) ==================
// ==================================================================

datetime GetBrokerDayStart(){ return iTime(NULL, PERIOD_D1, 0); }
bool IsWithinBrokerDay(datetime t, datetime dayStart){ return (t >= dayStart && t < dayStart + 86400); }

//+------------------------------------------------------------------+
//| DailyExtremeBreak logic for NoLine mode                          |
//+------------------------------------------------------------------+
void UpdateAndCheckDailyExtreme_NoLine() {
   bool lineMode = false;
   UpdateAndCheckDailyExtreme(lineMode);
}

//+------------------------------------------------------------------+
//| DailyExtremeBreak logic for Line mode                            |
//+------------------------------------------------------------------+
void UpdateAndCheckDailyExtreme_Line() {
   bool lineMode = true;
   UpdateAndCheckDailyExtreme(lineMode);
}

//+------------------------------------------------------------------+
//| Core logic for DailyExtremeBreak                                 |
//+------------------------------------------------------------------+
void UpdateAndCheckDailyExtreme(bool lineMode) {
   if (CurrentTradeDir == NoTrade) return;

   static datetime s_lastCheckedH1 = 0;
   datetime h1_closed_time = iTime(NULL, PERIOD_H1, 1);
   if (h1_closed_time == 0) return;
   if (h1_closed_time == s_lastCheckedH1) return;
   s_lastCheckedH1 = h1_closed_time;

   if (!IsInSession(TimeCurrent())) return;

   datetime dayStart = GetBrokerDayStart();
   double dayHighD1 = iHigh(NULL, PERIOD_D1, 0);
   double dayLowD1  = iLow (NULL, PERIOD_D1, 0);

   int max_bars = iBars(NULL, PERIOD_H1) - 1;

   int hi_shift = -1, lo_shift = -1;
   datetime hi_time = 0, lo_time = 0;
   double hi_bar_low = 0.0, lo_bar_high = 0.0;

   for (int shift = max_bars; shift >= 1; shift--) {
      datetime t = iTime(NULL, PERIOD_H1, shift);
      if (!IsWithinBrokerDay(t, dayStart)) continue;

      double h = iHigh(NULL, PERIOD_H1, shift);
      double l = iLow (NULL, PERIOD_H1, shift);

      if (hi_shift == -1 && AlmostEqual(h, dayHighD1)) { hi_shift = shift; hi_time = t; hi_bar_low = l; }
      if (lo_shift == -1 && AlmostEqual(l, dayLowD1))  { lo_shift = shift; lo_time = t; lo_bar_high = h; }
      if (hi_shift != -1 && lo_shift != -1) break;
   }

   bool high_in_window = (hi_shift != -1 && IsInSession(hi_time));
   bool low_in_window  = (lo_shift != -1 && IsInSession(lo_time));

   if (Debug){
      PrintFormat("[DEB][D1] dayStart=%s  High=%.5f (t=%s, inWin=%s)  Low=%.5f (t=%s, inWin=%s)",
         TimeToString(dayStart, TIME_DATE|TIME_MINUTES),
         dayHighD1, TimeToString(hi_time, TIME_DATE|TIME_MINUTES), high_in_window?"Y":"N",
         dayLowD1,  TimeToString(lo_time, TIME_DATE|TIME_MINUTES), low_in_window ?"Y":"N");
   }

   if (CurrentTradeDir == OnlySell){
      if (!high_in_window){
         if (Debug) Print("[DEB][SELL] Blocked: D1 High formed outside session. Waiting for new in-window High.");
      }else{
         double prev_close = iClose(NULL, PERIOD_H1, 1);
         if (prev_close < hi_bar_low){
            SignalCandle s;
            s.shift        = hi_shift;
            s.time         = h1_closed_time;
            s.extreme      = dayHighD1;
            s.entry_level  = hi_bar_low;
            s.Key          = ComposePatternKey(lineMode, false, hi_time, 0);

            if (!IsKeyUsed(s.Key)){
               double refPrice = s.entry_level;
               if (lineMode && !IsValidByLineGeometry(false, refPrice)){
                  if (Debug) Print("[DEB][SELL] Rejected by line geometry.");
                  return;
               }

               if (Debug) PrintFormat("[DEB][SELL] VALID (H1 close). D1.High=%.5f | Entry=%.5f | PrevClose=%.5f",
                                       dayHighD1, s.entry_level, prev_close);
               DrawSignalMarkers(s, false);
               PlacePendingDailyExtreme(s, false, lineMode);
            }
         }else if (Debug){
            PrintFormat("[DEB][SELL] Rejected: PrevClose(%.5f) >= BarLow(%.5f).", prev_close, hi_bar_low);
         }
      }
   }

   if (CurrentTradeDir == OnlyBuy){
      if (!low_in_window){
         if (Debug) Print("[DEB][BUY]  Blocked: D1 Low formed outside session. Waiting for new in-window Low.");
      }else{
         double prev_close = iClose(NULL, PERIOD_H1, 1);
         if (prev_close > lo_bar_high){
            SignalCandle s;
            s.shift        = lo_shift;
            s.time         = h1_closed_time;
            s.extreme      = dayLowD1;
            s.entry_level  = lo_bar_high;
            s.Key          = ComposePatternKey(lineMode, true, lo_time, 0);

            if (!IsKeyUsed(s.Key)){
               double refPrice = s.entry_level;
               if (lineMode && !IsValidByLineGeometry(true, refPrice)){
                  if (Debug) Print("[DEB][BUY] Rejected by line geometry.");
                  return;
               }

               if (Debug) PrintFormat("[DEB][BUY]  VALID (H1 close). D1.Low=%.5f | Entry=%.5f | PrevClose=%.5f",
                                       dayLowD1, s.entry_level, prev_close);
               DrawSignalMarkers(s, true);
               PlacePendingDailyExtreme(s, true, lineMode);
            }
         }else if (Debug){
            PrintFormat("[DEB][BUY] Rejected: PrevClose(%.5f) <= BarHigh(%.5f).", prev_close, lo_bar_high);
         }
      }
   }

   if (CurrentTradeDir == OnlySell && hi_shift == -1 && Debug)
      Print("[DEB][SELL] No H1 bar matched D1 High (full-day scan).");
   if (CurrentTradeDir == OnlyBuy && lo_shift == -1 && Debug)
      Print("[DEB][BUY]  No H1 bar matched D1 Low (full-day scan).");
}

//+------------------------------------------------------------------+
//| Place pending for DailyExtremeBreak                              |
//+------------------------------------------------------------------+
void PlacePendingDailyExtreme(const SignalCandle &s, bool isBuy, bool lineMode) {
   if (kOnePositionOnly && CountOpenPositions() > 0) return;

   if (IsKeyUsed(s.Key)) {
      if (Debug) Print("[DailyExtremeBreak] Skip pending: used key ", s.Key);
      return;
   }

   double entry = NormalizeDouble(s.entry_level, Digits);
   int type = isBuy ? OP_BUYLIMIT : OP_SELLLIMIT;
   if (!IsDirectionAllowed(type)) return;

   double stop_level = MarketInfo(Symbol(), MODE_STOPLEVEL) * Point;
   double freeze_lvl = MarketInfo(Symbol(), MODE_FREEZELEVEL) * Point;
   double min_dist = MathMax(stop_level, freeze_lvl);

   if (isBuy) {
      entry = MathMin(entry, Ask - min_dist);
      if (entry > Ask - min_dist) return;
   } else {
      entry = MathMax(entry, Bid + min_dist);
      if (entry < Bid + min_dist) return;
   }
   entry = NormalizeDouble(entry, Digits);

   double sl_dist = SL_Percent * ATR_D1_avg;
   double sl, tp;
   if (UseExtremeSL) {
      sl = isBuy ? NormalizeDouble(s.extreme - Point, Digits) : NormalizeDouble(s.extreme + Point, Digits);
      double dist = MathAbs(entry - sl);
      if (dist > 0.3 * ATR_D1_avg) {
         sl_dist = 0.3 * ATR_D1_avg;
         sl = NormalizeDouble(isBuy ? entry - sl_dist : entry + sl_dist, Digits);
         if (Debug) PrintFormat("[DailyExtremeBreak] SL adjusted to 0.3*ATR_D1_avg (%.5f)", sl);
      } else if (Debug) {
         PrintFormat("[DailyExtremeBreak] SL set beyond extreme (%.5f)", sl);
      }
   } else {
      sl = NormalizeDouble(isBuy ? entry - sl_dist : entry + sl_dist, Digits);
   }

   double tp_dist = TP_RR * sl_dist;
   tp = NormalizeDouble(isBuy ? entry + tp_dist : entry - tp_dist, Digits);

   double min_stop = MarketInfo(Symbol(), MODE_STOPLEVEL) * Point;
   if (MathAbs(sl - entry) < min_stop) {
      sl = isBuy ? NormalizeDouble(entry - min_stop, Digits) : NormalizeDouble(entry + min_stop, Digits);
   }
   if (MathAbs(tp - entry) < min_stop) {
      tp = isBuy ? NormalizeDouble(entry + min_stop, Digits) : NormalizeDouble(entry - min_stop, Digits);
   }

   double lot = CalculateLot(entry, sl);
   if (lot == 0.0) return;
// ⛔ DAILY LOSS LIMIT — блокируем выставление pending в этот день
if(!CanTradeToday())
{
   Print("[DAILY-LOSS-LIMIT] Pending (line mode) blocked. losses=",
         CountLosingTradesToday(), " limit=", MaxLosingTradesPerDay);
   return;
}

   if (PendingTicket > 0) {
      if (!kReplacePendingOnNewPattern) return;
      if (!OrderSelect(PendingTicket, SELECT_BY_TICKET)) {
         PendingTicket = 0;
         PendingPatternKey = "";
         return;
      }
      double prev_entry = OrderOpenPrice();
      bool better = (isBuy && entry <= prev_entry - Point) || (!isBuy && entry >= prev_entry + Point);
      if (!better) return;
      if (!OrderDelete(PendingTicket)) return;
      PendingTicket = 0;
      PendingPatternKey = "";
   }

   string mode_str = lineMode ? "Line" : "NoLine";
   string cmt = StringFormat("DailyExtremeBreak(%s)|PK:%s", mode_str, s.Key);
   color clr = isBuy ? clrGreen : clrRed;
   int ticket = OrderSend(Symbol(), type, lot, entry, kMaxSlippagePoints, sl, tp, cmt, MagicNumber, 0, clr);
   if (ticket > 0) {
      PendingTicket = ticket;
      PendingPlaceTime = TimeCurrent();
      PendingPlaceH1BarIndex = iBars(NULL, PERIOD_H1) - 1;
      PendingPatternKey = s.Key;
      if (Debug) Print("[DailyExtremeBreak] Placed pending: ", (type == OP_BUYLIMIT ? "BuyLimit" : "SellLimit"), " at ", DoubleToStr(entry, Digits), " | ", s.Key);
   } else {
      Print("[DailyExtremeBreak] Error placing pending: ", GetLastError());
   }
}
//+------------------------------------------------------------------+
